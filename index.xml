<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Guangchuang Yu</title>
    <link>https://guangchuangyu.github.io/cn/</link>
    <description>Recent content on Guangchuang Yu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Feb 2017 12:23:16 +0800</lastBuildDate>
    <atom:link href="https://guangchuangyu.github.io/cn/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ChIPseq简介</title>
      <link>https://guangchuangyu.github.io/cn/2017/02/chipseq%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 20 Feb 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/02/chipseq%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;ChIP是指染色质免疫沉淀，它通过特异结合抗体将DNA结合蛋白免疫沉淀，可以用于捕获蛋白质（如转录因子，组蛋白修饰）的DNA靶点。这技术存在非常久了，在二代测序之前，结合microarray，它的名字叫&lt;code&gt;ChIP-on-chip&lt;/code&gt;，二代测序出来之后，显而易见的，免疫沉淀拉下来的DNA拿去NGS测序，这必然是下一代的ChIP技术，优点也是显而易见的，不再需要设计探针（往往存在着一定的偏向性）。所以NGS出来以后，不差钱的牛逼实验室显然占据上风，谁先做出来，谁就定义了新技术。这是有钱人的竞赛，没钱的只能等着技术烂大街的时候跟风做。&lt;/p&gt;

&lt;p&gt;这是显而易见的下一代技术，外加技术上完全是可行的，所以这是一场单纯的时间竞赛，于是几乎同时出来CNS文章，基本上谁也不比谁差地同时扔出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Johnson DS, Mortazavi A et al. (2007) Genome-wide mapping of in vivo protein–DNA interactions. Science 316: 1497–1502&lt;/li&gt;
&lt;li&gt;Robertson G et al.(2007) Genome-wide profiles of STAT1 DNA association using chromatin immunoprecipitation and massively parallel sequencing. Nature Methods 4: 651–657&lt;/li&gt;
&lt;li&gt;Schmid et al. (2007) ChIP-Seq Data reveal nucleosome architecture of human promoters. Cell 131: 831–832&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2007年来自三个不同的实验室，几乎是同时间出来（最长差不了3个月），分别发CNS，一起定义了这个&lt;code&gt;ChIPseq&lt;/code&gt;技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/chipseq.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个技术分为4步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cross-linking&lt;/li&gt;
&lt;li&gt;Sonication&lt;/li&gt;
&lt;li&gt;IP&lt;/li&gt;
&lt;li&gt;Sequencing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNA和蛋白质交联(cross-linking)，超声(sonication)将染色体随机切割，利用抗原抗体的特异性识别(IP)，把&lt;strong&gt;目标蛋白&lt;/strong&gt;相结合的DNA片段沉淀下来，反交联释放DNA片段，最后是测序(sequencing)。&lt;/p&gt;

&lt;p&gt;一个典型的分析流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/ChIP-seq-1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;测序之后，我们当然首先需要做质量控制，然后就是做mapping，拿到这些DNA片段在染色体上的位置信息，ChIPseq的数据我们还需要做peak calling，把背景噪声去掉，比如上图中使用MACS做peak calling，这样我们就得到了protein binding site (peak)，就可以做下游的分析，比如可视化、相关的基因（比如最近的基因、宿主基因）、Motif分析等等。&lt;/p&gt;

&lt;p&gt;Peak annotation做的就是binding site的相关基因注释，在讲解&lt;code&gt;ChIPseeker&lt;/code&gt;的注释功能之前，下次先讲解一下peak calling的输出，BED文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wrapping labels in ggplot2</title>
      <link>https://guangchuangyu.github.io/cn/2017/02/wrapping-labels-in-ggplot2/</link>
      <pubDate>Tue, 14 Feb 2017 09:50:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/02/wrapping-labels-in-ggplot2/</guid>
      <description>&lt;p&gt;在公众号biobabble后台有多人同时在问这个问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-02-12-223832_646x667_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;晒这个截屏主要想说一点，如果是一两句话就能说清楚的问题，可以提问，如果不是，则不要在后台提问，写邮件或者到论坛提问，是更好的方式，像截屏中显示的，图片显示过期，我根本就没看到过图片。在手机上是无法看的，而我正好几天没在电脑前，于是你们发的图片我看不了，而且我如果没有在24小时之内回复，公众平台就不允许我回复了，因为问题已经过期。所以在此强调，不要在后台发图片提问，不要在后台问稍复杂的问题。&lt;/p&gt;

&lt;p&gt;这个问题其实很简单，用&lt;code&gt;stringr&lt;/code&gt;包的&lt;code&gt;str_wrap&lt;/code&gt;来完成文本自动换行就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
library(ggplot2)
library(clusterProfiler)
data(geneList)
de &amp;lt;- names(geneList)[1:100]
x &amp;lt;- enrichKEGG(de)
p &amp;lt;- barplot(x) 
p + scale_x_discrete(labels=function(x) str_wrap(x, width=10))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-02-12-225944_635x776_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微信公众文markdown一键排版</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E6%96%87markdown%E4%B8%80%E9%94%AE%E6%8E%92%E7%89%88/</link>
      <pubDate>Wed, 18 Jan 2017 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E6%96%87markdown%E4%B8%80%E9%94%AE%E6%8E%92%E7%89%88/</guid>
      <description>&lt;p&gt;微信公众号的后台排版功能很差，要想让读者阅读起来舒服，写作的人要花很多时间，于是出现了像&lt;code&gt;秀米&lt;/code&gt;这样的第三方排版网站，即便如此，要想排出好的版面，仍然是件耗时的事情，而且像在文章里贴代码这种小众需求，是不被支持的，代码就像普通文本，那叫一个乱。&lt;/p&gt;

&lt;p&gt;好在微信平台是支持富文本的，我们复制粘贴过来，格式都还会在，像抄我ggplot2那篇文的&lt;code&gt;生信人&lt;/code&gt;，就是完全复制粘贴的，还是我博客上的排版，当然它到了公众号上就乱了，我们其实很容易发现很多复制粘贴的，都没自己排一下版面，直接&lt;code&gt;ctrl-C&lt;/code&gt;, &lt;code&gt;ctrl-V&lt;/code&gt;一点诚意都没有。&lt;/p&gt;

&lt;p&gt;支持富文本这一点，意味着我们可以用&lt;code&gt;markdown&lt;/code&gt;呀！排版很容易，并且可以支持语法高亮。上一篇文章&lt;a href=&#34;https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/&#34;&gt;CorMut&lt;/a&gt;里，就是用了&lt;code&gt;markdown&lt;/code&gt;，被眼尖的小朋友发现，所以写出来，解答一下。&lt;/p&gt;

&lt;p&gt;我们需要的是，安装一个&lt;code&gt;markdown here&lt;/code&gt;的插件，firefox，chrome等都是支持的。&lt;/p&gt;

&lt;p&gt;比如下面这个：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003058_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我点一下markdown渲染，它自己就变成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003121_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这玩意其实是设计来写邮件的，有了它，邮件排版可以很牛逼，比如还是刚才的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003253_516x590_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们还可以通过定制&lt;code&gt;css&lt;/code&gt;，来改变字体、颜色等。简单的markdown语法，让排版轻松愉快，而且本身我的博客就是用markdown写的，写一份文档，博客和公众号两边推送。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> R包辣鸡之CorMut</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/</link>
      <pubDate>Tue, 17 Jan 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;曾经QQ上有人叫我帮忙，跑某个R包做个分析，我一看那包，一堆bug，显然不能用，那就不是简单的事了，我可没空帮他写代码，于是他就经常恶心我，有事没事就来说我写ggtree没意义，不是实质科研，不如跟他做点牛逼的，不如再写个R包干他那事。昨天用马甲在进化群里问画树，我还热心贴个代码给他，说看不懂，我在群里说了，我写个文详细介绍一下。然而他的马甲身份暴露啦，所以今日跳票，我写好的文也不发了，你牛逼就不要用马甲来骗代码呀，ggtree没用你不要用呀，叔就是这么任性😎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前讲过某个R包我一看一堆bug，直接放弃，今天倒是拿出来晒一下，不为别的，我只想说一句，一知半解是很危险的，盲目相信软件也是很危险的。&lt;/p&gt;

&lt;h2 id=&#34;比对-不比对-这是个严肃的问题:73d341715265d4d00941b1a9c2cbba18&#34;&gt;比对？不比对？这是个严肃的问题&lt;/h2&gt;

&lt;p&gt;话说此包的输入是alignment，我刚开始也没看代码，照着示例跑一下，但读序列的时候，我就惊呆了，怎么读个fasta这么慢，于是我开始看代码，不看不知道，一看吓一跳：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;seq_f01=as.list(sapply(allSeq,function(x)c2s(s2c(x)[ref01!=&amp;quot;-&amp;quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个s2c把string变成character vector，c2s则反过来，这一句就干一件简单的事情，就是把所有string（fasta读进来的sequences）中的-全部删除。就这么一切一贴，非常非常慢，简单地用&lt;code&gt;gsub(“-“, “”, allSeq)&lt;/code&gt;就可以非常快速做同样的事情。
然后这时候我们似乎觉得那里不妥！你把&lt;code&gt;-&lt;/code&gt;全删了，等于是把比对序列变成了非比对序列。那么你要求输入是比对序列是为什么？！
确实序列必须得是比对好的，因为这包就是要检测correlated mutations，它比的是codon, 这必须是比对好的序列才行，但在读序列的时候，就把-给删了，序列不再是比对好的，本来对应的codon现在必然很多都移位了，这在一开始就挖了巨大的坑。后面所有的计算必须都是辣鸡了。&lt;/p&gt;

&lt;h2 id=&#34;codon比较-数数字你会吗:73d341715265d4d00941b1a9c2cbba18&#34;&gt;codon比较，数数字你会吗？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Bioconductor-mirror/CorMut/blob/master/R/CorMut-internal.R#L125-L129&#34;&gt;https://github.com/Bioconductor-mirror/CorMut/blob/master/R/CorMut-internal.R#L125-L129&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(j in 1:length(seqf[[i]])){
	if(j%%3==1){ tris=seqf[[i]][j:(j+2)]
	}else if(j%%3==2){ tris=seqf[[i]][(j-1):(j+1)]
	}else if(j%%3==0){ tris=seqf[[i]][(j-2):j]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这循环竟然不是一个codon一个codon来，而是一个base一个base地迭代，这里移动三个位置，拿到的都是同一个codon，然后它就去比较是否不同，数数目了，一个不同，数它3遍，我也是醉了。&lt;/p&gt;

&lt;h2 id=&#34;p值你会算吗:73d341715265d4d00941b1a9c2cbba18&#34;&gt;p值你会算吗？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Bioconductor-mirror/CorMut/blob/release-3.4/R/kaksAA.R#L67-L77&#34;&gt;https://github.com/Bioconductor-mirror/CorMut/blob/release-3.4/R/kaksAA.R#L67-L77&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;LOD=0
Nnum=NS+NY
for(ii in NYs:Nnum){
	per_item=choose(Nnum,ii)*(q^ii)*((1-q)^(Nnum-ii))
	#avoid the appear of NaN
	if(per_item!=&amp;quot;NaN&amp;quot;){
		LOD=per_item+LOD
	}
	#print(choose(dim(mat)[2],i)*(q^i)*((1-q)^(dim(mat)[2]-i)))
}
LOD=-log10(LOD)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道算p值是算积分面积，它倒好，离散性分布这一个个数字来计算，然后求合。
这里用的是二项式分布：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;per_item=choose(Nnum,ii)(q^ii)((1-q)^(Nnum-ii))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个基本上你算出来会有很多0和NaN，精度问题嘛，这样算必须是不准的。然后他必须是跑了自己代码出不来p值，发现有很多NaN，也不去想为什么，直接把NaN给扔了。这根本就是错的，也不知道用pbinom去算，我也是服了。&lt;/p&gt;

&lt;h2 id=&#34;总结:73d341715265d4d00941b1a9c2cbba18&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我只是粗略地看了一下代码，就发现很多错误，而且几乎每个重要的部分都出错。问题肯定比我粗略看一下所能发现地多得多。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读序列，把比对的序列搞成了非比对。&lt;/li&gt;
&lt;li&gt;比较codon，序列非比对这比毛线啊，然后连数数目都数错。&lt;/li&gt;
&lt;li&gt;p值，简单二项式，你都不会算啊，简单粗暴地对NaN视而不见。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这货中国CDC出品，竟然还发了Bioinformatics，reviewer简直瞎眼了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-09-002515_560x405_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ChIPseq从入门到放弃</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/chipseq%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</link>
      <pubDate>Sun, 08 Jan 2017 22:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/chipseq%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</guid>
      <description>&lt;p&gt;接下来要出一个ChIPseq系列，讲一讲ChIPseq和我的ChIPseeker包，从入门到放弃是我自己的个人写照。我做ChIPseq总共也就3个月的时间，做的事情并不多，在一知半解的情况下写下了ChIPseeker包。&lt;/p&gt;

&lt;p&gt;我当时被要求做ChIPseq分析是为他人做嫁衣，而且是完全白干那种，但做为学生，白干也得干。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/1487166664.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当时一开始使用ChIPpeakAnno做注释，但用UCSC genome browser检验结果的时候，发现对不上。在对ChIPpeakAnno包不满意的情况下，开始着手写ChIPseeker，其实在使用ChIPpeakAnno的时候，我就有写代码对结果做一些可视化，所以未有ChIPseeker先有ChIPseeker的部分可视化功能。当时写了篇博客文说ChIPpeakAnno的问题，一个月后就在Bioconductor上发表了ChIPseeker，这包完全是我半夜在宿舍里写出来的。&lt;/p&gt;

&lt;p&gt;当时还在生物系，被我炒掉的前老板每天要求必须起码在实验室待够12小时，我每天都待到10点半左右才回宿舍，日常在实验室里啥都干不了，白天各种瞎折腾，晚上还要陪他聊天，但说来说去，每天几乎都差不多，无非是他很牛逼，我们这帮人读他phd实在太幸运，日复一日传销式洗脑。而我因为结婚了，家又离得近，周末回家，白天经常多一段单独对我的洗脑，做为一个PhD学生，在发表文章之前是不能够有周末的。每天10半从实验室里出来，回到宿舍11点，跟老婆打电话再洗澡，12点。然后从12点开始写代码到2点睡觉，才有了这个包。&lt;/p&gt;

&lt;p&gt;虽然是一知半解的时候开发的，但还是受到大家的欢迎，半年前Matt邀请我去人大做报告时，也专门提到了ChIPseeker。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-08-212729_758x479_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也有美国的助理教授，跟我要paper，说是上课的时候，要给学生读的，这广告效果我给满分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-08-213021_777x396_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;文章发表了一年，已经被33篇文章引用，其中不乏有影响因子比较高的杂志：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-08-213354_874x413_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面是其中一些引用文章的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/featured_img/ChIPseeker/journal.pcbi.1004751.g003.PNG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/featured_img/ChIPseeker/F9.large.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/featured_img/ChIPseeker/heatmap2016.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;虽然ChIPseeker是我写给自己做ChIPseq注释的，但Ming Tang (&lt;a href=&#34;https://github.com/crazyhottommy/ChIP-seq-analysis）用它去做DNA&#34;&gt;https://github.com/crazyhottommy/ChIP-seq-analysis）用它去做DNA&lt;/a&gt; breakdown注释，当然像lincRNA注释也是有人做并且完全是支持的。有一些我以前从没在文档里提到的东西，也应该会在这个系列里写出来。&lt;/p&gt;

&lt;p&gt;这个系列基本上是围绕着ChIPseeker的功能而来，名副其实从入门到放弃，因为我自己也是入了门然后放弃，如果想看从入门到精通的，这显然不适合你。&lt;/p&gt;

&lt;p&gt;然而今天只是个剧透，敬请期待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>clifun:在R里装装逼</title>
      <link>https://guangchuangyu.github.io/cn/2016/12/clifun%E5%9C%A8r%E9%87%8C%E8%A3%85%E8%A3%85%E9%80%BC/</link>
      <pubDate>Tue, 13 Dec 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/12/clifun%E5%9C%A8r%E9%87%8C%E8%A3%85%E8%A3%85%E9%80%BC/</guid>
      <description>&lt;p&gt;天天活在命令行下，需要一些有趣的小命令来调节一下枯燥的生活（其实是需要装装逼）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/clifun/Screen Shot 2016-12-12 at 1.42.00 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;fortune可以随机打印一些「名言」，figlet可以把字母变成ascii图案，而cowsay可以画一只小动物来打印输入的句子，最后是lolcat，让输出变成彩虹色。然后它们的组合，通过管道，让逼格升级。&lt;/p&gt;

&lt;p&gt;在R命令行里面呢，fortune有R包，不过名言换成了R社区的「名言」，你可以把fortunes::fortune()加到~/.Rprofile里面，这样每次打开R，都可以随机看到一句「名言」，不过看久了，也会厌烦，因为大量的话都是在吹R有多牛逼、用户有多傻。&lt;/p&gt;

&lt;p&gt;&amp;lsquo;They&amp;rsquo; did write documentation that told you that Perl was needed, but &amp;lsquo;they&amp;rsquo; can&amp;rsquo;t read it for you.
   &amp;ndash; Brian D. Ripley
      R-help (February 2001&lt;/p&gt;

&lt;p&gt;像这种吐槽用户不看文档之类的，我还是挺赞同的😜&lt;/p&gt;

&lt;p&gt;cowsay也有个相应的R包，就像fortune是不一样的fortune一样，这个cowsay和命令行的cowsay也是不一样的，行为差不多，但收集的动物是不一样的。&lt;/p&gt;

&lt;p&gt;最近我给这个包加了个小恶魔，BSD的logo，我一直比较喜欢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/clifun/2016-12-13 09.44.53.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;比如你每次打开R，可以让R显示一只小动物在讲一句「名言」：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/clifun/Screen Shot 2016-12-13 at 7.34.13 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但对于用figlet和lolcat装逼的人来讲，总还是觉得少了点什么。&lt;/p&gt;

&lt;p&gt;所以呢，我写了两个wrapper functions，打包在&lt;a href=&#34;https://github.com/GuangchuangYu/clifun&#34;&gt;clifun&lt;/a&gt;，分别是figlet和lolcat函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/GuangchuangYu/clifun/master/clifun.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是大家可以在R里装装逼了，特别是你可以加入类似于下面的命令：
clifun::lolcat(cowsay::say(clifun::figlet(&amp;ldquo;YGC&amp;rdquo;), by=&amp;lsquo;fish&amp;rsquo;, type=&amp;lsquo;string&amp;rsquo;))&lt;/p&gt;

&lt;p&gt;到~/.Rprofile里面。&lt;/p&gt;

&lt;p&gt;这样子，每次你打开R：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/clifun/Screen Shot 2016-12-13 at 7.55.48 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不一样的欢迎消息，不一样的逼格。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>跨物种计算基因相似性</title>
      <link>https://guangchuangyu.github.io/cn/2016/12/%E8%B7%A8%E7%89%A9%E7%A7%8D%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%9B%A0%E7%9B%B8%E4%BC%BC%E6%80%A7/</link>
      <pubDate>Wed, 07 Dec 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/12/%E8%B7%A8%E7%89%A9%E7%A7%8D%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%9B%A0%E7%9B%B8%E4%BC%BC%E6%80%A7/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I know this question has been asked before a long time ago and I don&amp;rsquo;t see an answer of that question in the mailing list or in the vignette of GOsemsim package. So I was wondering what is the easiest possible way of calculating GO semantic similarity value for orthologus gene pairs between two species using the above R package or any other package you know of. I am not doing this for less annotated species I need to calculate that for orthologus genes between Human and Mouse (both of which are well annotated IMHO). So I would much appreciate it if anyone who has already done this before can point me to a resource which already has pre-calculated semantic similarity values for Mouse and Human orthologues or has inbuilt code to do that.&lt;/p&gt;

&lt;p&gt;Thanks &amp;amp; regards&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是Bioconductor support site上的&lt;a href=&#34;https://support.bioconductor.org/p/90063/&#34;&gt;问题&lt;/a&gt;，问的是他想要计算人类和老鼠的直系同源基因通过GO注释来计算语义相似性，问GOSemSim是否支持，这个答案是yes and no。&lt;/p&gt;

&lt;p&gt;本身是没有直接支持跨物种计算的，GOSemSim最初支持5个物种，后面扩展为20个物种，现在是支持有OrgDb的所有物种，而OrgDb是可以通过AnnotationHub在线获取的，也可以通过AnnotationForge::makeOrgPackage()函数或者是makeOrgPackageFromNCBI()函数构建，所以现在基本上GOSemSim和clusterProfiler都是可以说支持所有有注释的物种，当然没注释的也可以自己注释，通过拿来计算。&lt;/p&gt;

&lt;p&gt;GOSemSim默认是支持单一物种，首先通过godata()函数把OrgDb转化为GOSemSim所需要的注释，包括基因映射到GO以及GOID的信息含量，然后这个背景注释传给geneSim/mgeneSim函数，godata()只支持传入单一OrgDb，所以这里只能是支持单一物种，要跨物种也不是不可能，我再写一个merge函数，把godata()输出的GOSemSimDATA对象合并起来，比如一个人的，一个老鼠的，merge完之后，你还可以再merge，这样就可以有多个物种的注释在里面。就可以传给geneSim/mgeneSim来计算了，所有的函数都不需要做出改变，只需要添加这一功能就好。对于使用GO图结构的算法，这没什么问题，但对于使用信息含量的算法，merge的过程，可能需要对信息含量重新计算/处理，这也是我迟迟没写扩展的原因，因为没时间研究这些-,-&lt;/p&gt;

&lt;p&gt;虽然直接是不支持的，至少目前是这样（以后可以真会加入像上面提到的功能），但稍微变通一下，就知道其实是可以的，因为你可以使用图结构算法（不涉及信息含量的计算），然后用mgoSim来计算啊，只不过你需要自己做基因到GO的映射而已，你拿一人的基因，对应一个GOID向量，一个老鼠基因，对应另一个GOID向量，做为输入给mgoSim，就可以算出来这两个基因的相似性，简单的wrapper函数，就可以干这个事情了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Linked List to solve Josephus problem</title>
      <link>https://guangchuangyu.github.io/cn/2016/12/using-linked-list-to-solve-josephus-problem/</link>
      <pubDate>Sun, 04 Dec 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/12/using-linked-list-to-solve-josephus-problem/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这个问题是以弗拉维奥·约瑟夫斯命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。  &amp;ndash; &lt;a href=&#34;https://zh.wikipedia.org/wiki/约瑟夫斯问题&#34;&gt;https://zh.wikipedia.org/wiki/约瑟夫斯问题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是一个比较简单的问题，n个人围成圆圈，越过k-1个人，杀掉第k个人，如此反复直到只剩下最后一个人。可以用数学推导给出答案，问题本身已经足够简单，用链表可以模拟整个过程。实现起来比较直观。这里在初始化这个链表的时候，需要注意，到了最后一人的时候，他应该指向第一个人，这样才能形成一个环状的链表，然后问题就非常简单了，从第一人开始，后面就无所谓头和尾了，按照规则来，每次杀掉一个人，直到只剩下最后一人，就是结果。从维基的解释可以看出，最后两个人没死，这没节操的事情被拿来说，如果你数学好，你就可以救自己一命（站在合适的位置，让自己是最后一个）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;sstream&amp;gt;

typedef struct person {
  int ID;
  struct person * next;
} person;

int main() {
  std::ifstream infile(&amp;quot;data/id32.txt&amp;quot;);
  std::string line;
  getline(infile, line);
  int n, k;
  std::stringstream ss(line);
  ss &amp;gt;&amp;gt; n;
  ss &amp;gt;&amp;gt; k;

  person *head = new person;
  head-&amp;gt;ID = 1;
  person *prenode = head;
  for (int i=2; i&amp;lt;=n; i++) {
    person *node = new person;
    node-&amp;gt;ID = i;
    prenode-&amp;gt;next = node;
    prenode = node;
    if (i == n)
      node-&amp;gt;next = head;
  }


  int left = n;
  int i=1;
  person *node = new person;
  node = head;
  while (left &amp;gt; 1) {
    if (i % k == 0) {
      prenode-&amp;gt;next = node-&amp;gt;next;
      left--;
    } else {
      prenode = node;
    }

    i++;
    node = node-&amp;gt;next;
  }
  std::cout &amp;lt;&amp;lt; node-&amp;gt;ID &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>中空的环形树</title>
      <link>https://guangchuangyu.github.io/cn/2016/12/%E4%B8%AD%E7%A9%BA%E7%9A%84%E7%8E%AF%E5%BD%A2%E6%A0%91/</link>
      <pubDate>Sat, 03 Dec 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/12/%E4%B8%AD%E7%A9%BA%E7%9A%84%E7%8E%AF%E5%BD%A2%E6%A0%91/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/iss95.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/GuangchuangYu/ggtree/issues/95&#34;&gt;github&lt;/a&gt;上的问题，他想画环形树的时候，加一条长长的root length把tips给顶出去。&lt;/p&gt;

&lt;p&gt;这个问题在google forum上我早已解答：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/Screen Shot 2016-11-30 at 9.06.01 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我在google group上教会的这个人，他的文章发表在&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/27605062&#34;&gt;nature communications&lt;/a&gt;上，下面是pubmed上的截图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/Screen Shot 2016-11-30 at 9.06.57 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简直亮瞎了我的狗眼，我看到这图，一口老血差别喷出来，这画的什么玩意，啥都看不清。&lt;/p&gt;

&lt;p&gt;我本来以为他要把中间做空，是为了把legend放进去，结果不是，尼玛也太空了，而且tips根本分不清关系，满篇文章都是这种图，附件上更多，好一朵奇葩。&lt;/p&gt;

&lt;p&gt;但是github上的问题，让我重新认识了这样的图，就像提问者说的，他想把tip给顶出去，这样容易看到tip label，某种程度上，这不失为一个好方法，一种好折中，但像上面那个顶得太厉害了，我依然接受不了。&lt;/p&gt;

&lt;p&gt;实现起来也容易，提问者说figtree可以做，通过搞一条长长的root length来实现，这个在ggtree里，当然也可以这么做，但我做空环形树或者说顶一顶tip label，根本就不需要用额外画条线来顶/撑开圆形，但思路是一样的，无非是要给左边留更多空间，这样在旋转成极坐标的时候，左边的空间就变成了内部的空间，于是中间就空了。&lt;/p&gt;

&lt;p&gt;所以呢，+xlim(负数, NA) 就是这么简单，就可以了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>无中生有windows版R包</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/%E6%97%A0%E4%B8%AD%E7%94%9F%E6%9C%89windows%E7%89%88r%E5%8C%85/</link>
      <pubDate>Wed, 30 Nov 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/%E6%97%A0%E4%B8%AD%E7%94%9F%E6%9C%89windows%E7%89%88r%E5%8C%85/</guid>
      <description>&lt;p&gt;之前帮助高老师实现比对序列的做图，把代码打包为R包seqcombo，方便安装使用。花两小时的作品，发现还有些用户在使用 -，-&lt;/p&gt;

&lt;p&gt;之前有人联系我说安装不上，我觉得不应该有这个问题，因为是纯R代码代码，不涉及到编译，源码包安装不应该有问题。但既然有人问，又都是windows用户，我想可以给他们提供编译好的windows包，简化安装过程（这么体贴用户，我都要被自己感动了）。&lt;/p&gt;

&lt;p&gt;放在CRAN或Bioconductor上的R包，CRAN和Bioconductor会编译出不同平台的二进制包，但seqcobo放在github上，只有源代码，没有预编译好的包，但没有不是问题，我编译好放上去就行了。&lt;/p&gt;

&lt;p&gt;但问题是我没有windows！多年来一直是OSX和linux，MacBook Pro跑Arch Linux，一台iMac跑OSX，我自己根本没有跑windows的机器，所以难为无米之炊，借台机器总是有的，但总不能每次一更新，就拷个代码去别人的机器上打包，再拷回来上传到网上，想想也是蛋疼。&lt;/p&gt;

&lt;p&gt;所以没有windows，这事干起来还不太容易，！在想怎么来无中生有生出个windows包出来的时候，我想起了rhub，也是因为没有windows，之前就用rhub来进行windows平台的R check，在把代码push到CRAN或Bioconductor之前，我总会测试没问题了，再提交代码过去，而rhub正好可以给我提供windows平台的检测。&lt;/p&gt;

&lt;p&gt;在R check完之后，rhub会把check之前build的包存起来，正是这一点，为我们提供了这无米之炊，这时候我就可以下载它来放到我的repo里，这也算是一个变通的办法。&lt;/p&gt;

&lt;p&gt;然而，我要等它check完，再去下载，放到repo，push到github上，动作太多，太繁琐，所以必须写代码让它自动化起来。&lt;/p&gt;

&lt;p&gt;于是写了Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-make&#34;&gt;windows:
	Rscript -e &#39;rhub::check_on_windows(&amp;quot;.&amp;quot;)&#39;
addtorepo: windows
	Rscript -e &#39;drat:::insert(&amp;quot;../$(PKGNAME)_$(PKGVERS).tar.gz&amp;quot;, &amp;quot;../drat/docs&amp;quot;)&#39;;\
	Rscript -e &#39;drat:::insert(ypages::get_windows_binary(), &amp;quot;../drat/docs&amp;quot;);\
	cd ../drat;\
	git add .; git commit -m &#39;$(PKGNAME)_$(PKGVERS)&#39;; git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我只要&lt;code&gt;make addtorepo&lt;/code&gt;一条指令，它就会自动运行传到rhub的windows平台check我的包，check结束后，下载rhub平台编译的包，然后用&lt;code&gt;drat:::insert&lt;/code&gt;来把它放到合适的位置，并生成相应的文件（如包的依赖关系、md5sum等），再把它push到github上去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://guangchuangyu.github.io/blog_images/Bioconductor/Screen Shot 2016-11-23 at 6.11.14 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我用了一条&lt;code&gt;ypages::get_windows_binary()&lt;/code&gt;指令来检验rhub check是否结束，如果是则把编译的包下载到临时文件，并作为输入传到&lt;code&gt;drat:::insert&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ypages&lt;/code&gt;也是一个R包，我用来搞github pages的私人定制包，比如我各种包的主页上那些badge图标，显示下载量、版本号、文章引用数目等相关信息的图标，都是通过ypages自动生成的，没有放出来，所以细节不在这里讲，这里主要介绍一个思路，利用rhub云平台来编译windows二进制包，放入私人repo供用户下载安装，通过makefile自动化这一过程。Makefile才是最通用的可重复性研究工具，你值得拥有。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vertical dendrogram in ggtree</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/vertical-dendrogram-in-ggtree/</link>
      <pubDate>Tue, 29 Nov 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/vertical-dendrogram-in-ggtree/</guid>
      <description>&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/guangchuangyu&#34;&gt;@guangchuangyu&lt;/a&gt; Is it possible to plot horizontal trees with ggtree? (a la plot.hclust default).&lt;/p&gt;&amp;mdash; Diego Diez (@kurai_yousei) &lt;a href=&#34;https://twitter.com/kurai_yousei/status/799532564633518080&#34;&gt;November 18, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;这个Diego在推特上问的问题，他最近在写一个&lt;a href=&#34;https://github.com/ddiez/motiftools&#34;&gt;motiftools&lt;/a&gt;的R包，里面用了ggtree来画图，我想他应该是要解决他在包里的画树/聚类功能吧。&lt;/p&gt;

&lt;p&gt;他问题写的horizontal，但其实plot.hclust默认是vertical，ggtree默认也是horizontal，所以我认为他问的是vertical layout，这个在我的回答中也得到了他的确认。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; require(ggtree)
&amp;gt; set.seed(123)
&amp;gt; tr = rtree(30)
&amp;gt; ggtree(tr) + scale_x_reverse() + coord_flip()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个问题很简单，无非是坐标轴翻转而已。于是上面的代码，就得到下面的图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/Screen Shot 2016-11-21 at 7.53.54 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ggtree支持多种布局(layout)，rectangular（上面这种就是，父节点到子节点由90度折线连接），slated（父节点到子节点由直线连接）， circular（圆圈型，父节点到子节点的连接方式可以是rectangular也可以是slanted），fan（顾名思义-扇子型，也可以理解为有开口的圆圈，实际上ggtree提供了open_tree函数，可以把circular的树转变为fan layout），unrooted（无根树，连接方式是slanted，但没有根节点，所以可以说有些说圆圈型，但没有中心），还有二维树（把y轴利用起来，可以映射到节点的phenotype或者是统计推断的估值）。&lt;/p&gt;

&lt;p&gt;上面提到的这些布局，都可以有画phylogram或cladogram，差别在于phylogram有branch length而cladogram没有。而在层次聚类中，做的是聚类，而不是进化树，这是不同的概念，所以画出来的图相似，但却是不一样的东西，所以聚类分析的图叫dendrogram，像上面这个图，就是典型的dendrogram画法，显然看着和进化树是没什么差别的，只不过进化树一般从左到右画，而dendrogram画这种从上到下的形状还是比较常见的。虽然是不一样的东西，但从画图的角度来看，dendrogram和rectangular layout的phylogram/cladogram是一样的。所以要问ggtree能不能画dendrogram的形状，当然可以，要问能不能从上到下，当然可以，无非是坐标轴颠过来倒过去而已，就算你要画出从下到上，从右到左，都是没有问题的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>buildGOmap</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/buildgomap/</link>
      <pubDate>Mon, 28 Nov 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/buildgomap/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://guangchuangyu.github.io/blog_images/Bioconductor/clusterProfiler/640.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;周末Bioconductor上的问题，说的是他用了buildGOmap之后，在终端上输出了一长串，但没有文件产生，今天就来讲讲这个buildGOmap的前世今生。&lt;/p&gt;

&lt;p&gt;当年写clusterProfiler的时候在暨大工作，主要也是自己的需求驱动，因为实验室里有做细菌，比如肺炎链球菌D39，在细菌界基本上所谓的GO分析，就是跑个电子注释，然后数一下数目，列个表格画个饼图。很难看到有富集性分析的身影，因为绝大多数的工具是只支持少量模式生物的，还有部分工具比如支持某些细菌，支持某些植物或者某些真菌，比如支持植物的，也只是支持少量的植物物种而已，都是些自己定制给自己用的玩意，放出来只是为了顺道灌水而已。&lt;/p&gt;

&lt;p&gt;说到富集性分析，大家第一感觉是这玩意烂大街了，工具非常多。如果是说超几何分布检验的话，可以说是对的。但如果说GSEA的话，工具并没有那么多，也不像超几何分布那种，有一堆web server，你看大家喜欢/最有名的DAVID, wego都不能做GSEA，因为GSEA复杂一些（门槛高一点），计算量大一些（让web sever不太现实）。即使是超几何分布，烂大街的也是模式生物，对于一些细菌真菌、新物种什么的，还是很难找到称手的工具，当然有一些工具，可以支持用户自己的注释文件，像在R里面，可以支持用户自己的注释信息存在data.frame或list做为输入，这极大方便了用户整理注释信息并继而做分析。&lt;/p&gt;

&lt;p&gt;我当年一开始是用GO::TermFinder (&lt;a href=&#34;http://search.cpan.org/dist/GO-TermFinder/lib/GO/TermFinder.pm)，&#34;&gt;http://search.cpan.org/dist/GO-TermFinder/lib/GO/TermFinder.pm)，&lt;/a&gt; 一个perl module，我印象中要定制分析非常麻烦，而且要修改配置文件。当然在Bioconductor上有GOstats，这个包是可以支持用户注释的，然而调用时要先构建参数对象，我老记不住，对于我这种脑容量不够的人来说，最好是直接调用函数出结果，然后它的输出也有一些问题，比如不会列出到底有那些基因属于这些报出来的enriched terms。当时还写过一些helper function来导出结果时把额外的一些信息加进去。&lt;/p&gt;

&lt;p&gt;当时写clusterProfiler的驱动主要有：
我要用自己的注释数据，我希望改变实验室所谓GO分析只是列表格计数画饼图的现状，
我希望能够有更全面的信息，比如上面提到的genes in enrich term，这个我还专门加了个readable的参数，自己转化为gene symbol方便人类阅读
画图的需求，当时有比较不同情况的想法，这也是这个包名的出处。&lt;/p&gt;

&lt;p&gt;当时写了GO和KEGG，并且支持了大概20个物种，而用户自己的GO注释，是这样来实现的，如果输入的物种不是支持的那20个，那么在工作目录里寻找注释文件，而这些注释文件，就是由buildGOmap产生，所以流程就是buildGOmap -&amp;gt; enrichGO。这个buildGOmap会把间接注释加上去（所以比较慢）然后整理成enrichGO所需要的注释，产生文件保存在工具目录中。&lt;/p&gt;

&lt;p&gt;然而这只是最初的clusterProfiler，做为一个良心之作，在发表文章之后，不断更新，现在GO已经支持非常多的物种，KEGG支持超过3千个物种而且是在线数据（多半的工具在用过时数据），还有其它比如Broad Institute的Molecular Signatures Database等各种注释，以及用户自己的注释信息。并且GSEA也是支持的。&lt;/p&gt;

&lt;p&gt;所以呢用户自己（定制）的注释信息现在是单独支持，不仅限于GO，那么之前buildGOmap -&amp;gt; enrichGO的流程就不再需要了，你可以用你的注释信息直接用enricher/GSEA分析，如果你分析的是GO，并用你的注释只有直接注释，那么你可以用buildGOmap把间接注释加上去，然后再用enricher/GSEA分析，所以现在的流程是buildGOmap(optional and only for GO) -&amp;gt; enricher/GSEA。在现在clusterProfiler里，buildGOmap不会产生文件，而是输出一个data.frame，做为background annotation输入给enricher(超几何检验）或GSEA。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用emoji画图</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/%E4%BD%BF%E7%94%A8emoji%E7%94%BB%E5%9B%BE/</link>
      <pubDate>Fri, 25 Nov 2016 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/%E4%BD%BF%E7%94%A8emoji%E7%94%BB%E5%9B%BE/</guid>
      <description>&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&#34;&gt;#rstats&lt;/a&gt; code for the PhD/cute animals gestation &lt;a href=&#34;https://twitter.com/hashtag/ggplot2?src=hash&#34;&gt;#ggplot2&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/gganimate?src=hash&#34;&gt;#gganimate&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/emojifont?src=hash&#34;&gt;#emojifont&lt;/a&gt; plot &lt;a href=&#34;https://t.co/qWM0bCHoHJ&#34;&gt;https://t.co/qWM0bCHoHJ&lt;/a&gt; 🐭🐶🐱🐺🐯🐷🐏🐻👶🐳🐘📕 &lt;a href=&#34;https://t.co/a4GYl191a8&#34;&gt;https://t.co/a4GYl191a8&lt;/a&gt;&lt;/p&gt;&amp;mdash; Maëlle Salmon (@ma_salmon) &lt;a href=&#34;https://twitter.com/ma_salmon/status/800007428096094209&#34;&gt;November 19, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;无缘无故收到好几条消息，原来是用emoji画图。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/pboesu&#34;&gt;@pboesu&lt;/a&gt; btw do you know the &lt;a href=&#34;https://twitter.com/guangchuangyu&#34;&gt;@guangchuangyu&lt;/a&gt; emojifont pkg? I&amp;#39;ve used it more than &lt;a href=&#34;https://twitter.com/millerdl&#34;&gt;@millerdl&lt;/a&gt; emoGG &lt;a href=&#34;https://t.co/p27fwEmDSD&#34;&gt;https://t.co/p27fwEmDSD&lt;/a&gt; but I like both &lt;a href=&#34;https://t.co/uV49WjOSp3&#34;&gt;https://t.co/uV49WjOSp3&lt;/a&gt;&lt;/p&gt;&amp;mdash; Maëlle Salmon (@ma_salmon) &lt;a href=&#34;https://twitter.com/ma_salmon/status/800009044123586560&#34;&gt;November 19, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;做为emojifont包的作者，我表示很高兴看到自己的包给大家带来乐趣，在回复中@milerdl说emoGG是他用了两个晚上写的，emojifont刚好也是我用了两个晚上写的，一个晚上支持了emoji字体，另一个晚上加入了fontawesome字体。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Hi &lt;a href=&#34;https://twitter.com/guangchuangyu&#34;&gt;@guangchuangyu&lt;/a&gt; excellent &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/emojifont?src=hash&#34;&gt;#emojifont&lt;/a&gt; implementation! &lt;a href=&#34;https://t.co/lTIWDQ1zq0&#34;&gt;https://t.co/lTIWDQ1zq0&lt;/a&gt; very cool! &lt;a href=&#34;https://t.co/sCALpuWW28&#34;&gt;pic.twitter.com/sCALpuWW28&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jo-fai (Joe) Chow (@matlabulous) &lt;a href=&#34;https://twitter.com/matlabulous/status/677205176663588865&#34;&gt;December 16, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;

&lt;p&gt;在写这个包之前，我早就有用emoji在R画图中，写这个包也正是为了回应emoGG，因为我觉得他的实现方式并不理想，而我的更为灵活。&lt;/p&gt;

&lt;p&gt;回到主题上，我将展示使用emojifont来画图。&lt;/p&gt;

&lt;p&gt;下面这个数据是我每年读书、看电影、听专辑的数目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; d
   year category num
1  2009     book  35
2  2009    movie  64
3  2009    music  24
4  2010     book  34
5  2010    movie  47
6  2010    music  13
7  2011     book  17
8  2011    movie  18
9  2011    music   2
10 2012     book  25
11 2012    movie  25
12 2012    music   0
13 2013     book  15
14 2013    movie  17
15 2013    music   0
16 2014     book   8
17 2014    movie  11
18 2014    music   1
19 2015     book   5
20 2015    movie  14
21 2015    music   0
22 2016     book   4
23 2016    movie  14
24 2016    music   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先加载所需的包和emoji字体：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(ggplot2)
require(ggthemes)
require(emojifont)
load.emojifont()
emo &amp;lt;- emoji(c(&amp;quot;book&amp;quot;, &amp;quot;movie_camera&amp;quot;, &amp;quot;musical_note&amp;quot;))
names(emo) &amp;lt;- c(&#39;book&#39;, &#39;movie&#39;, &#39;music&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画出趋势图，并在每个点上用相应的emoji字体标注：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p &amp;lt;- ggplot(d, aes(x=factor(year), y=num, group=category, colour=category))
p &amp;lt;- p +geom_line() +geom_text(aes(label=emo[category]), family=&#39;OpenSansEmoji&#39;, size=10) +xlab(NULL) + ylab(NULL) 

更改一些背景等主题细节，设置中文字体等：
p &amp;lt;- p + theme_fivethirtyeight() + scale_color_tableau()
p &amp;lt;- p+theme(axis.text.x=element_text(face=&amp;quot;bold&amp;quot;, size=16), 
        axis.text.y=element_text(face=&amp;quot;bold&amp;quot;, size=16))
 p &amp;lt;- p+theme(legend.text=element_text(size=16, family=&amp;quot;OpenSansEmoji&amp;quot;), 
            legend.title=element_blank(), legend.position=&#39;none&#39;)
p+ ggtitle(&#39;Y叔的书影音&#39;) + theme(plot.title=element_text(family=&#39;STKaiti&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是产生下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/Screen Shot 2016-11-21 at 7.47.34 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>食色性也</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/%E9%A3%9F%E8%89%B2%E6%80%A7%E4%B9%9F/</link>
      <pubDate>Mon, 21 Nov 2016 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/%E9%A3%9F%E8%89%B2%E6%80%A7%E4%B9%9F/</guid>
      <description>&lt;p&gt;画图配色并不是一件简单的事情，好的配色让人眼前一亮，虽然R有很多配色方案，做为ggplot2的爱好者，ggthemes也提供了很多主题，内置了很多配色方案，还有一些其它的包，比如ggtech，包含了一些科技公司比如facebook, twitter, google的典型配色方案，甚至于ggsci，提供了nature, lancet的配色方案。&lt;/p&gt;

&lt;p&gt;但这些远远不够！
但这些远远不够！
但这些远远不够！&lt;/p&gt;

&lt;p&gt;看到一张图片让我眼前一亮，我想用它的配色方案呢！我想拿最新电影的海报的配色来装个逼呢！画图时不想用现成的配色，想要另类一些，我想用一些大自然的风格，比如求偶期间各种鸟类的羽毛颜色来画！&lt;/p&gt;

&lt;p&gt;这些在R里面，都是可以的，可以的，可以的&amp;hellip;&lt;/p&gt;

&lt;p&gt;下面隆重推荐一个叫rPlotter的R包，&lt;a href=&#34;https://github.com/woobe/rPlotter&#34;&gt;https://github.com/woobe/rPlotter&lt;/a&gt;，可以非常方便地在图片中抽提颜色。其实实现起来也容易，用EBImage把图片读进去，存成一个RGB的三维矩阵，通过kmeans聚类，把中心点颜色报出来就可以了。若干年前我写过用kmeans压缩图片，用的就是把颜色填充成中心点颜色，稍微把之前的代码改一改，也能实现这个颜色抽提的功能。&lt;/p&gt;

&lt;p&gt;实例演示，我google了一张spider的图片，把颜色提出来，拿来画barplot：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/Jumping-spider.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pal = extract_colours(&amp;quot;http://i1.mirror.co.uk/incoming/article8566552.ece/ALTERNATES/s615b/Jumping-spider.jpg&amp;quot;)
barplot(1:5, col=pal)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/spider_color.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再来一张homer simpson的图片：
&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/kissing-Homer-Simpson-The-Simpsons-Marge-Simpson-_578180-20_zx1jpk.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pal2 = extract_colours(&amp;quot;https://images.complex.com/complex/image/upload/t_article_image/kissing-Homer-Simpson-The-Simpsons-Marge-Simpson-_578180-20_zx1jpk.jpg&amp;quot;, 7)
barplot(1:7, col=pal2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/homer_color.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之前说的各种场景，都是可以实现的，最新海报配色，你可以有！你想画图用美队来配色，可以有！拿蜘蛛小鸟来配色，可以有！甚至于拿肌肉男的肉色也可以的。下次发文章在愁配色的时候，何不搜索图片，看看有什么图片顺眼的，就拿来用了。&lt;/p&gt;

&lt;p&gt;即使你不会用R画图，你也可以把这配色方案应该于M$的office中，word/excel/powerpoint都是支持自定义颜色主题的，请自行搜索 &amp;ldquo;office 自定义主题颜色&amp;rdquo;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DNA序列差异作图</title>
      <link>https://guangchuangyu.github.io/cn/2016/11/dna%E5%BA%8F%E5%88%97%E5%B7%AE%E5%BC%82%E4%BD%9C%E5%9B%BE/</link>
      <pubDate>Sat, 19 Nov 2016 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2016/11/dna%E5%BA%8F%E5%88%97%E5%B7%AE%E5%BC%82%E4%BD%9C%E5%9B%BE/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/640.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是高老师&lt;a href=&#34;http://link.springer.com/article/10.1007/s11540-015-9307-3&#34;&gt;文章&lt;/a&gt;里的图，每一个小图都是通过比较两条比对序列差异而做出来的，从图A和B中可以看出，CF_YL21有可能是Mont和Oz两条序列重组而来。高老师自己做出这图后，深知手工统计序列差异、画图、拼图之困难。问我有没有办法读两条序列，生成一个图。&lt;/p&gt;

&lt;p&gt;很多东西都没有现成的，需要自己造轮子，于是我写了个R包来做这个事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;library(seqcombo)
fas = list.files(system.file(&amp;quot;examples&amp;quot;,&amp;quot;GVariation&amp;quot;, package=&amp;quot;seqcombo&amp;quot;), 
pattern=&amp;quot;fas&amp;quot;, full.names=TRUE)
x = seqdiff(fas[1])
plot(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/Screen Shot 2016-11-17 at 8.25.26 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一行代码读文件，然后plot画出来，就是这么简单。&lt;/p&gt;

&lt;p&gt;这里有三个文件，我们可以三个文件一起读，三个图一起画。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = lapply(fas, seqdiff)
plts = lapply(x, plot)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后可以很容易把三张图拼在一起&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cowplot::plot_grid(plotlist=plts, ncol=1, labels=LETTERS[1:3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2016/Screen Shot 2016-11-17 at 8.20.21 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简直完美，跟文章中的图一毛一样。&lt;/p&gt;

&lt;p&gt;这个包我取名&lt;a href=&#34;https://github.com/GuangchuangYu/seqcombo&#34;&gt;seqcombo&lt;/a&gt;，90后大概不知道何为combo，如果你知道，没错，说的就是你，你已经暴露年龄了！因为这个图是可以辅助看序列重组的，所以取这个名字，以后有可能的话，再实现一些其它的可视化方法，起码得有三把刷子，才对得起combo这名字。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>