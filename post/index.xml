<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Guangchuang Yu</title>
    <link>https://guangchuangyu.github.io/cn/post/</link>
    <description>Recent content in Posts on Guangchuang Yu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 05 Apr 2017 12:23:16 +0800</lastBuildDate>
    <atom:link href="https://guangchuangyu.github.io/cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>generate biobabble banner using ggimage</title>
      <link>https://guangchuangyu.github.io/cn/2017/04/generate-biobabble-banner-using-ggimage/</link>
      <pubDate>Wed, 05 Apr 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/04/generate-biobabble-banner-using-ggimage/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/biobabble_banner.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;制作了一个banner，用来插入到文后，方便阅读到最后的时候，直接扫描关注。&lt;/p&gt;

&lt;p&gt;这图当然用PS一下就可以得到，无非是拼图和加点文字。但做为天天写代码画图的人来说，必然是要纯代码来产生的，而且做科学的人，讲究自动化、可重复性。&lt;/p&gt;

&lt;p&gt;就像有些人不理解data scentist为什么讨厌excel一样，觉得无非是工具，没什么好搞阵营的。试想一下，一个分析流程中间有一步要用到excel，需要人工去点点鼠标，这对于讲究自动化、可重复性的data scientist来说是不可接受的。&lt;/p&gt;

&lt;h2 id=&#34;加载中文字体:966da26016f51c32cab8c8a1572665e3&#34;&gt;加载中文字体&lt;/h2&gt;

&lt;p&gt;为了打几个中文字，需要先加载字体，这里我用showtext。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(showtext)
font.add(&amp;quot;heiti&amp;quot;, &amp;quot;/Library/Fonts/华文黑体.ttf&amp;quot;)
showtext.auto()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;读图:966da26016f51c32cab8c8a1572665e3&#34;&gt;读图&lt;/h2&gt;

&lt;p&gt;两个图，一个是logo，一个是二维码，分别用&lt;strong&gt;EBImage&lt;/strong&gt;读入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(EBImage)
require(grid)

gc &amp;lt;- rasterGrob(image=readImage(&#39;gc.png&#39;))
page &amp;lt;- rasterGrob(image=readImage(&#39;biobabble_page.png&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;图上嵌图:966da26016f51c32cab8c8a1572665e3&#34;&gt;图上嵌图&lt;/h2&gt;

&lt;p&gt;这里用我自己写的&lt;strong&gt;ggimage&lt;/strong&gt;包的&lt;strong&gt;geom_subview&lt;/strong&gt;来嵌图，然后无非打几个字，设一下字体。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(ggimage)
pg &amp;lt;- ggplot(d=data.frame(x=c(0,10), y=c(0,5)), aes(x, y)) + geom_blank() + coord_fixed()
pg &amp;lt;- pg+geom_subview(gc, x=2.5, y=2.5, width=5.1, height=5.1) + geom_subview(page, x=7.5, y=2.5, width=4.8, height=4.8)

pg &amp;lt;- pg+theme_void() + labs(title=&amp;quot;长按二维码关注biobabble&amp;quot;, subtitle=&amp;quot;欢迎分享朋友圈&amp;quot;,caption=&#39;guangchuangyu@gmail.com&#39;) + theme(title=element_text(family=&amp;quot;heiti&amp;quot;, size=20))
ggsave(pg, file=&amp;quot;biobabble_banner.png&amp;quot;, width=8, height=5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是产生下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/biobabble_banner.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ggplot2字体溢出的那点破事</title>
      <link>https://guangchuangyu.github.io/cn/2017/04/ggplot2%E5%AD%97%E4%BD%93%E6%BA%A2%E5%87%BA%E7%9A%84%E9%82%A3%E7%82%B9%E7%A0%B4%E4%BA%8B/</link>
      <pubDate>Mon, 03 Apr 2017 15:10:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/04/ggplot2%E5%AD%97%E4%BD%93%E6%BA%A2%E5%87%BA%E7%9A%84%E9%82%A3%E7%82%B9%E7%A0%B4%E4%BA%8B/</guid>
      <description>&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require(ggplot2)
d &amp;lt;- data.frame(x=c(0, 0.002, 0.00575), y = 1:3)
p &amp;lt;- ggplot(d, aes(x, y)) + geom_point() + xlab(NULL) + ylab(NULL)
print(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/geom_text_files/figure-markdown_strict/unnamed-chunk-1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面图中x轴的文本&lt;strong&gt;0.006&lt;/strong&gt;，这个数字中的&lt;strong&gt;6&lt;/strong&gt;几乎看不到，因为一半过界了。&lt;/p&gt;

&lt;p&gt;这种情况还可以更糟糕，比如我把字体搞大点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p &amp;lt;- p + theme(axis.text=element_text(size=12))
print(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/geom_text_files/figure-markdown_strict/unnamed-chunk-1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简直了，&lt;strong&gt;6&lt;/strong&gt;都看不见了。第一次遇到这种情况，都会觉得这软件也太傻了！连坐标轴都会过界！但事实上，这是一个普遍的现象。因为像点这些，是数据空间，但文本是像素空间，只会按照指定的大小转化为多少个像素，然后把字打出来，这些当然容易打过界了。特别是如果把文本打在数据点的右边，比如我们画进化树时，需要画tip label，这纯粹是在右边打字的，文本通常只有部分显示出来，解决方案就在&lt;strong&gt;ggtree&lt;/strong&gt;的&lt;a href=&#34;https://guangchuangyu.github.io/ggtree/faq/#tip-label-truncated&#34;&gt;文档&lt;/a&gt;里，用&lt;code&gt;xlim&lt;/code&gt;搞大右边。比如这个例子的话，&lt;code&gt;+xlim&lt;/code&gt;很容易解决的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p + xlim(NA, 0.0062)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/geom_text_files/figure-markdown_strict/unnamed-chunk-1-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然复杂的情况也是有的，比如你在分面的时候，只有某个分面溢出了，而&lt;code&gt;scales&lt;/code&gt;又是&lt;code&gt;free&lt;/code&gt;的，你直接&lt;code&gt;+xlim&lt;/code&gt;会应用于所有分面，但在free scale的情况下，你只想应用到某一分面，这个也是可以搞的，参考&lt;a href=&#34;https://guangchuangyu.github.io/2016/10/xlim_tree-set-x-axis-limits-for-only-tree-panel/&#34;&gt;xlim_tree&lt;/a&gt;，做为思考题，看大家能不能悟出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;讲ggtree各种技巧，对于你们学ggplot2也是极有帮助的！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>关于ChIPseq注释的几个问题</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/%E5%85%B3%E4%BA%8Echipseq%E6%B3%A8%E9%87%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 31 Mar 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/%E5%85%B3%E4%BA%8Echipseq%E6%B3%A8%E9%87%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</guid>
      <description>

&lt;h2 id=&#34;为什么我要用某个基因组版本:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;为什么我要用某个基因组版本？&lt;/h2&gt;

&lt;p&gt;在上一篇文章中，我用了&lt;code&gt;TxDb.Hsapiens.UCSC.hg19.knownGene&lt;/code&gt;。 &lt;strong&gt;hg19&lt;/strong&gt;的&lt;strong&gt;TxDb&lt;/strong&gt;, 或者有人就要问了，为什么不用&lt;strong&gt;hg38&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;这个问题，不是说要用那一个，不能用那一个。而是你必须得用某一个，这取决于你最初&lt;strong&gt;fastq&lt;/strong&gt;用BWA/Bowtie2比对于某个版本的基因组，你最初用了某个版本，后面就得用相应的版本，不能混，因为不同版本的位置信息有所不同。&lt;/p&gt;

&lt;p&gt;当然如果要（贵圈喜欢的）强搞，也不是不可以，你得有chain file，先跑个liftOver，实际上就是在两个基因组版本之间做了位置转换。&lt;/p&gt;

&lt;h2 id=&#34;为什么说-chipseeker-支持所有物种:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;为什么说&lt;strong&gt;ChIPseeker&lt;/strong&gt;支持所有物种？&lt;/h2&gt;

&lt;p&gt;背景注释信息用了&lt;strong&gt;TxDb&lt;/strong&gt;就能保证所有物种都支持了？我去哪里找我要的&lt;strong&gt;TxDb&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;我写&lt;strong&gt;ChIPseeker&lt;/strong&gt;的时候，我做的物种是人，&lt;strong&gt;ChIPseeker&lt;/strong&gt;在线一周就有剑桥大学的人写信跟我说在用&lt;strong&gt;ChIPseeker&lt;/strong&gt;做果蝇，在&lt;a href=&#34;https://guangchuangyu.github.io/cn/2017/03/bed%E6%96%87%E4%BB%B6/&#34;&gt;BED文件&lt;/a&gt;一文中，也提到了最近有人在Biostars上问用&lt;strong&gt;ChIPseeker&lt;/strong&gt;做裂殖酵母。&lt;/p&gt;

&lt;p&gt;首先Bioconductor提供了30个TxDb包，可以供我们使用，这当然只能覆盖到一小部分物种，我们的物种基因组信息，多半要从UCSC或者Ensembl获得，我敢说支持所有物种，就是因为UCSC和ensembl上所有的基因组都可以被&lt;strong&gt;ChIPseeker&lt;/strong&gt;支持。&lt;/p&gt;

&lt;p&gt;因为我们可以使用&lt;strong&gt;GenomicFeatures&lt;/strong&gt;包函数来制作TxDb对象：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;makeTxDbFromUCSC： 通过UCSC在线制作TxDb&lt;/li&gt;
&lt;li&gt;makeTxDbFromBiomart: 通过ensembl在线制作TxDb&lt;/li&gt;
&lt;li&gt;makeTxDbFromGRanges：通过GRanges对象制作TxDb&lt;/li&gt;
&lt;li&gt;makeTxDbFromGFF：通过解析GFF文件制作TxDb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如我想用人的参考基因信息来做注释，我们可以直接在线从UCSC生成&lt;strong&gt;TxDb&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(GenomicFeatures)
hg19.refseq.db &amp;lt;- makeTxDbFromUCSC(genome=&amp;quot;hg19&amp;quot;, table=&amp;quot;refGene&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如最近在&lt;strong&gt;biostars&lt;/strong&gt;上有用户问到的，做裂殖酵母的注释，我们可以下载相应的&lt;strong&gt;GFF&lt;/strong&gt;文件，然后通过&lt;strong&gt;makeTxDbFromGFF&lt;/strong&gt;函数生成&lt;strong&gt;TxDb&lt;/strong&gt;对象，像下面的命令所演示，&lt;strong&gt;spombe&lt;/strong&gt;就是生成的&lt;strong&gt;TxDb&lt;/strong&gt;，就可以拿来做裂殖酵母的ChIPseq注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;download.file(&amp;quot;ftp://ftp.ebi.ac.uk/pub/databases/pombase/pombe/Chromosome_Dumps/gff3/schizosaccharomyces_pombe.chr.gff3&amp;quot;, &amp;quot;schizosaccharomyces_pombe.chr.gff3&amp;quot;)

require(GenomicFeatures)
spombe &amp;lt;- makeTxDbFromGFF(&amp;quot;schizosaccharomyces_pombe.chr.gff3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我敢说，所有物种都支持。像Johns Hopkins出品的CisGenome就只支持到12个物种而已，极大地限制了它的应用。&lt;/p&gt;

&lt;h2 id=&#34;chipseeker-有什么不能注释的吗:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;&lt;strong&gt;ChIPseeker&lt;/strong&gt;有什么不能注释的吗？&lt;/h2&gt;

&lt;p&gt;这个我还没想到，像CpG是不支持的，但也有人「黑」出来了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/2017-03-13-003520_618x444_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然他的做法是把CpG也整合进去，如果你单纯只想看那些peak落在CpG上，或者说离CpG最近，不需要「黑」也能做到的，因为&lt;strong&gt;annotatePeak&lt;/strong&gt;的背景注释信息除了TxDb之外，其实它还可以是自定义的&lt;strong&gt;GRanges&lt;/strong&gt;对象，这保证了用户各种各样的需求，因为TxDb也不是万能的，如果能自定义，比如说我就只想看蛋白的结合位点会不会在内含子和外显子的交界处，再比如说我做的并不是编码蛋白的基因表达调控，而是非编码RNA，那么我想要用lncRNA的位置信息来做注释。像这样的需求，&lt;strong&gt;ChIPseeker&lt;/strong&gt;都是可以满足的。&lt;/p&gt;

&lt;h2 id=&#34;可以按正负链分开注释吗:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;可以按正负链分开注释吗？&lt;/h2&gt;

&lt;p&gt;上一篇文章中就有人问了，能否同时给出正负链上最近的基因。首先ChIPseq数据通常情况下是没有正负链信息的（有特殊的实验可以有），&lt;strong&gt;annotatePeak&lt;/strong&gt;函数有参数是&lt;strong&gt;sameStrand&lt;/strong&gt;，默认是FALSE，你可以给你的peak分别赋正负链，然后传入&lt;strong&gt;sameStrand=TRUE&lt;/strong&gt;，分开做两次，你就可以分开拿到正链和负链的最近基因。&lt;/p&gt;

&lt;h2 id=&#34;最近基因位置是相对于tss的-能否相对于整个基因:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;最近基因位置是相对于TSS的，能否相对于整个基因？&lt;/h2&gt;

&lt;p&gt;答案也是可以的！&lt;/p&gt;

&lt;p&gt;首先如果peak和TSS有overlap，genomic annotation就是promoter，而最近基因也是同一个，所以在这种情况下，两种注释都指向同一个基因，可以说信息是冗余的，能不能不要冗余信息？这个是可以的，你可以传入参数&lt;strong&gt;ignoreOverlap=TRUE&lt;/strong&gt;，那么最近基因就会去找不overlap的。&lt;/p&gt;

&lt;p&gt;最近基因是相对于TSS，如果和TSS有overlap，距离是0, 必须是最近。回到标题的问题，如果我想说只要和基因有overlap就是最近基因，这种情况其实你的最近基因就是host gene，也就是annotation这个column给出来的是相对应的，我们就想找peak所在位置的基因信息，那么这当然也是可以的，默认参数&lt;strong&gt;overlap=&amp;ldquo;TSS&amp;rdquo;&lt;/strong&gt;, 如果改为&lt;strong&gt;overlap=&amp;ldquo;all&amp;rdquo;&lt;/strong&gt;，它看的就是整个基因而不是TSS，当然&lt;strong&gt;distanceToTSS&lt;/strong&gt;也还是会计算，如果overlap的不是TSS，而是基因体里，并不会因为而设为0。&lt;/p&gt;

&lt;h2 id=&#34;如果我只想注释上游或者是下游的基因呢:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;如果我只想注释上游或者是下游的基因呢？&lt;/h2&gt;

&lt;p&gt;当然也可以，我们有&lt;strong&gt;ignoreUpstream&lt;/strong&gt;和&lt;strong&gt;ignoreDownstream&lt;/strong&gt;参数，默认都是FALSE。随便你想看上游还是下游，都可以。&lt;/p&gt;

&lt;h2 id=&#34;为什么要有这么多参数:015d79cbc951e2a010a6c641978ec0b8&#34;&gt;为什么要有这么多参数？&lt;/h2&gt;

&lt;p&gt;我在前一篇，只讲了输入，输出，你知道两个输入，会看输出，你就可以做ChIPseq注释了，非常简单。但是我不能把annotatePeak能做的全列出来，会让大家觉得复杂。（而且简单的情况是最常见的行为）&lt;/p&gt;

&lt;p&gt;在大家知道输入输出，觉得简单之后，再讲一讲，它有一些参数，可以应对别的情况，这些情况可能并不是我们做ChIPseq所需要的，但不同参数的灵活组合，是可以解决和应对不同的需求的。&lt;/p&gt;

&lt;p&gt;比如说, DNA是可以断的，如果我们要对（DNA breakpoints）断点位置做注释，优先是overlap基因，再者是上游，你会发现很多软件都不能做了，但&lt;strong&gt;ChIPseeker&lt;/strong&gt;可以。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;做软件关键是要注重细节，不单注重自己需求的细节，更主要是要注重别人的细节&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>News in emojifont</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/news-in-emojifont/</link>
      <pubDate>Thu, 23 Mar 2017 14:30:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/news-in-emojifont/</guid>
      <description>&lt;p&gt;面向对象有多种实现方式，R里面就有3种，class-based, method-based, object-based，R6与C++/JAVA一样是class-based的，S3/S4是method-based的，还有一种是object-based的，这在proto包中实现，很多人可能没听说过，但是ggplot2你们一定听过，ggplot2就是object-based的实现，它现在是自己的定制实现，称之为ggproto。&lt;/p&gt;

&lt;p&gt;emojifont就是用proto实现的，属于我的练手之作，很高兴深受大家的喜欢。&lt;/p&gt;

&lt;p&gt;如果我想看一个emoji长啥样，用&lt;strong&gt;ggplot2&lt;/strong&gt;还是麻烦点，用ggplot2是这样画的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/tree.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而用base plot，则相对简单些：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/Screen Shot 2017-02-14 at 8.00.23 PM.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;于是我有了要写个&lt;strong&gt;geom_emoji&lt;/strong&gt;图层的想法：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我在想应该利用emojifont，写个geom_emoji图层，这样直接ggplot()+geom_emoji(&amp;ldquo;broken_heart&amp;rdquo;)就可以直接出来，ggplot()+geom_emoji(&amp;ldquo;chicken&amp;rdquo;)就出来一只，虽然emojifont已足够易用，但减少输入更加傻瓜，还是可以有的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;过了一天，我就写了&lt;strong&gt;geom_emoji&lt;/strong&gt;，于是如果我想看某个emoji长什么样，比如下面画个玫瑰花：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot() + geom_emoji(&amp;quot;rose&amp;quot;) + theme_void()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/rose.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这次的更新，我还换个emoji字体，升级到unicode 9，也就是最新加入的鸭子也能用咯：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot() + geom_emoji(&amp;quot;duck&amp;quot;) + theme_void()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/duck.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;geom_emoji&lt;/strong&gt;让画散点也变得简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- seq(-sqrt(17), sqrt(17), length.out=30)
y1 &amp;lt;- 8*abs(x)/17 + 15* sqrt(17 - x^2)/17
y2 &amp;lt;- 8*abs(x)/17 - 15* sqrt(17 - x^2)/17
ggplot() + geom_emoji(&amp;quot;gift_heart&amp;quot;, x=x, y=c(y1, y2), color=&amp;quot;red&amp;quot;, size=10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/heart_of_heart.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;制作动图gif也是非常简单，这个代码简直如同人类语言一般：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;require(ggplot2)
require(magick)
require(purrr)

x &amp;lt;- search_emoji(&amp;quot;heart&amp;quot;)

plot_heart=function(x) {
 p = ggplot() + geom_emoji(x)
 o = paste0(x, &amp;quot;.png&amp;quot;)
 ggsave(o, p, width=5, height=5)
 o
 }

x %&amp;gt;% map(plot_heart) %&amp;gt;% map(image_read) %&amp;gt;% 
image_join() %&amp;gt;% image_animate(fps=1) %&amp;gt;% 
image_write(&amp;quot;heart.gif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/R/emojifont/heart.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为换了字体，所以和之前的不同，如果要去背景，只需要&lt;code&gt;+theme_void()&lt;/code&gt;就可以。&lt;/p&gt;

&lt;p&gt;新版也不同你加载字体的，随包载入自动加载，当然以前的字体还能用，还用一样的办法手工加载。（所以说我这次升级很考究，原来的字体，老方法，新字体你啥都不用干）&lt;/p&gt;

&lt;p&gt;同时加入的还有&lt;strong&gt;geom_fontawesome&lt;/strong&gt;图层，最新画hex sticker，用fontawesome蛮好用 -,-&lt;/p&gt;

&lt;p&gt;这次更新，主要有3方面：升级了新字体，支持unicode 9；新加入的图层让你非常方便地看一看emoji表情长啥样；再者不需要手工加载字体了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我在网上看到香港R用户组的教学视频，发现我被‘出镜了’，讲解了emojifont包，好像我在香港还有点小名气，然而我并没有露过脸，视频中也没有。&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/t-tLnvaYKHw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>how to bug author</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/how-to-bug-author/</link>
      <pubDate>Mon, 20 Mar 2017 15:10:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/how-to-bug-author/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.devtang.com/2017/03/05/how-to-get-help/&#34;&gt;http://blog.devtang.com/2017/03/05/how-to-get-help/&lt;/a&gt; 这篇文章讲问问题的礼仪，会问问题的人容易得到别人的帮助，并不是作者拽，而是对着一群不会问问题，且一副理所当然的用户，早就有了深深的无力感，也看看我写的这篇吧，&lt;a href=&#34;https://guangchuangyu.github.io/2016/07/how-to-bug-author/&#34;&gt;https://guangchuangyu.github.io/2016/07/how-to-bug-author/&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是前几天的文字推送，不知道大家有没有阅读这两篇博客文？如何提问，这是一项重要的技能，很遗憾很多人并没有这项技能！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/413360782.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;就在上周，我正好就在微信群里跟某位老师说不要给我个截屏，说能不能在ggtree里实现某功能。懂的人知道，我只是希望大家用正确的方式来做事情，不懂的人，当然觉得我拽，JJYY什么的。&lt;/p&gt;

&lt;p&gt;以前暨大有个博士生，跟我QQ和微信上都留言说要学某个R包，快点教他，我没回复，过几天又继续留言，我就把他给喷一顿。港真，都读到博士了，这点道理不应该不懂，要学自己学，遇到问题再来问，唯有下图可以表达我的观点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/ubiaoqing581356c41441430498.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;UNIX的世界里，那句”read the fucking man”，早有了属于它自己的缩写RTFM，不信你们google一下这4个字母，这里的man是指manual，因为UNIX下查看manual的指令就是man，读文档是非常重要的，很多问题在文档里已经有了答案，但用户就是不愿意花时间去读。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-03-19-234106_792x722_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近有人看我博客文，说没有&lt;strong&gt;geom_barh&lt;/strong&gt;，简直日狗了，那篇博客明明就专门介绍了&lt;strong&gt;ggstance&lt;/strong&gt;包，所以我专门贴了XKCD画的RTFM图，最好他们会脸红！&lt;/p&gt;

&lt;p&gt;学术界很多人情商低得很，有问题直接甩作者，还认为作者应该毕恭毕敬地回复。&lt;strong&gt;没有任何人有义务要帮你解决问题！没有任何人有义务要帮你解决问题！没有任何人有义务要帮你解决问题！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-03-19-235129_854x663_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我在github上设了模版，如果用户提问，就会有向导，像上面截屏这个，他愿意花时间按着我的向导来，我就愿意花时间帮他解决问题。&lt;/p&gt;

&lt;p&gt;为什么我要强调看文档？要什么提问前要先google一下？原因很简单，你首先愿意对自己的问题花时间！你自己不愿意花时间，你凭什么要求别人为你花时间！&lt;/p&gt;

&lt;p&gt;为什么在上面微信截图里我强调在github开个issue好好描述问题？为什么我在github模版里要强调可重复性例子？你花时间把自己的问题描述情楚，整理自己的代码让别人可以重复出你的问题，这是在节省别人帮你解决问题的时间，也就是说这是在尊重别人的时间！尊重别人也是尊重自己！你的问题更有可能得到解答，别人会更愿意帮助你，即使你的问题很白痴，别人也会本着要对新手nice的态度对待你。而那些不读文档的伸手党，则往往只会得到RTFM四个字母的回(xiu)复(ru)。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>peak注释</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/peak%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Thu, 16 Mar 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/peak%E6%B3%A8%E9%87%8A/</guid>
      <description>

&lt;p&gt;这一次讲解非常重要的peak注释，注释在&lt;strong&gt;ChIPseeker&lt;/strong&gt;里只需要用到一个函数&lt;strong&gt;annotatePeak&lt;/strong&gt;，它可以满足大家各方面的需求。&lt;/p&gt;

&lt;h2 id=&#34;输入:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;输入&lt;/h2&gt;

&lt;p&gt;当然需要我们上次讲到的BED文件，&lt;strong&gt;ChIPseeker&lt;/strong&gt;自带了5个BED文件，用&lt;strong&gt;getSampleFiles()&lt;/strong&gt;可以拿到文件的全路径，它返回的是个named list，我这里取第4个文件来演示。&lt;strong&gt;annotatePeak&lt;/strong&gt;的输入也可以是&lt;strong&gt;GRanges&lt;/strong&gt;对象，你如果用R做peak calling的话,直接就可以衔接上&lt;strong&gt;ChIPseeker&lt;/strong&gt;了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; require(ChIPseeker)
&amp;gt; f = getSampleFiles()[[4]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;巧妇难为无米之炊，就像拿到&lt;strong&gt;fastq&lt;/strong&gt;要跑&lt;strong&gt;BWA&lt;/strong&gt;，你需要全基因组的序列一样，做注释当然需要注释信息，基因的起始终止，基因有那些内含子，外显子，以及它们的起始终止，非编码区的位置，功能元件的位置等各种信息。&lt;/p&gt;

&lt;p&gt;很多软件会针对特定的物种去整理这些信息供软件使用，但这样就限制了软件的物种支持，有些开发者写软件本意也是解决自己的问题，可能对自己的研究无关的物种也没兴趣去支持。&lt;/p&gt;

&lt;p&gt;然而&lt;strong&gt;ChIPseeker&lt;/strong&gt;支持所有的物种，你没有看错，&lt;strong&gt;ChIPseeker&lt;/strong&gt;没有物种限制，当然这是有前提的，物种本身起码是有基因的位置这些注释信息，不然就变无米之炊了。&lt;/p&gt;

&lt;p&gt;这里我们需要的是一个&lt;strong&gt;TxDb&lt;/strong&gt;对象，这个&lt;strong&gt;TxDb&lt;/strong&gt;就包含了我们需要的各种信息，&lt;strong&gt;ChIPseeker&lt;/strong&gt;会把信息抽取出来，用于注释时使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; require(TxDb.Hsapiens.UCSC.hg19.knownGene)
&amp;gt; txdb = TxDb.Hsapiens.UCSC.hg19.knownGene
&amp;gt; x = annotatePeak(f, tssRegion=c(-1000, 1000), TxDb=txdb)
&amp;gt;&amp;gt; loading peak file...				 2017-03-09 11:29:18 PM 
&amp;gt;&amp;gt; preparing features information...		 2017-03-09 11:29:18 PM 
&amp;gt;&amp;gt; identifying nearest features...		 2017-03-09 11:29:19 PM 
&amp;gt;&amp;gt; calculating distance from peak to TSS...	 2017-03-09 11:29:20 PM 
&amp;gt;&amp;gt; assigning genomic annotation...		 2017-03-09 11:29:20 PM 
&amp;gt;&amp;gt; assigning chromosome lengths			 2017-03-09 11:29:42 PM 
&amp;gt;&amp;gt; done...					 2017-03-09 11:29:42 PM 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里需要注意的是，启动子区域是没有明确的定义的，所以你可能需要指定&lt;strong&gt;tssRegion&lt;/strong&gt;，把基因起始转录位点的上下游区域来做为启动子区域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了这两个输入（BED文件和TxDb对象），你就可以跑注释了，然后就可以出结果了。&lt;/p&gt;

&lt;h2 id=&#34;输出:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;输出&lt;/h2&gt;

&lt;p&gt;如果在R里打输出的对象，它会告诉我们ChIPseq的位点落在基因组上什么样的区域，分布情况如何。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; x
Annotated peaks generated by ChIPseeker
1331/1331  peaks were annotated
Genomic Annotation Summary:
             Feature  Frequency
9           Promoter 48.1592787
4             5&#39; UTR  0.7513148
3             3&#39; UTR  4.2073629
1           1st Exon  0.7513148
7         Other Exon  3.9068370
2         1st Intron  3.6814425
8       Other Intron  7.7385424
6 Downstream (&amp;lt;=3kb)  1.1269722
5  Distal Intergenic 29.6769346
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我想看具体的信息呢？你可以用&lt;strong&gt;as.GRanges&lt;/strong&gt;方法，这里我只打印前三行：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/2017-03-09-235213_697x358_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Bioconductor里有很多包是针对&lt;strong&gt;GRanges&lt;/strong&gt;对象的，这样方便你在R里做后续的处理，如果你说你不懂这些，只想输出个Excel表格。那么也很容易，用&lt;strong&gt;as.data.frame&lt;/strong&gt;就可以转成&lt;strong&gt;data.frame&lt;/strong&gt;，然后你就可以用&lt;strong&gt;write.table&lt;/strong&gt;输出表格了。&lt;/p&gt;

&lt;h2 id=&#34;两种-不同的注释:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;两种&lt;strong&gt;不同的注释&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这里注释有两种，一种是genomic annotation (也就是annotation这一列）还有就是nearest gene annotation（也就是多出来的其它列）。&lt;/p&gt;

&lt;p&gt;经常有人问我问题，把这两种搞混。genomic annotation注释的是peak的位置，它落在什么地方了，可以是UTR，可以是内含子或者外显子。&lt;/p&gt;

&lt;p&gt;而最近基因是peak相对于转录起始位点的距离，不管这个peak是落在内含子或者别的什么位置上，即使它落在基因间区上，我都能够找到一个离它最近的基因（即使它可能非常远）。&lt;/p&gt;

&lt;p&gt;这两种注释的策略是不一样的。针对不同的问题。第一种策略peak所在位置，可能就是调控的根本，比如你要做可变剪切的，最近基因的注释显然不是你关注的点。&lt;/p&gt;

&lt;p&gt;而做基因表达调控的，当然promoter区域是重点，离结合位点最近的基因更有可能被调控。&lt;/p&gt;

&lt;p&gt;最近基因的注释信息虽然是以基因为单位给出，但我们针对的是转录起始位点来计算距离，针对于不同的转录本，一个基因可能有多个转录起始位点，所以注释是在转录本的水平上进行的，我们可以看到输出有一列是&lt;strong&gt;transcriptId&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;第三种注释:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;第三种注释&lt;/h2&gt;

&lt;p&gt;两种注释有时候还不够，我想看peak上下游某个范围内（比如说-5k到5k的距离）都有什么基因，&lt;strong&gt;annotatePeak&lt;/strong&gt;也可以做到。&lt;/p&gt;

&lt;p&gt;你只要传个参数说你要这个信息，还有什么区间内，就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = annotatePeak(f[[4]], tssRegion=c(-1000, 1000), TxDb=txdb, addFlankGeneInfo=TRUE, flankDistance=5000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/2017-03-10-001539_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;输出中多三列: &lt;strong&gt;flank_txIds&lt;/strong&gt;, &lt;strong&gt;flank_geneIds&lt;/strong&gt;和&lt;strong&gt;flank_gene_distances&lt;/strong&gt;，在指定范围内所有的基因都被列出。&lt;/p&gt;

&lt;h2 id=&#34;基因注释:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;基因注释&lt;/h2&gt;

&lt;p&gt;对于通常情况找最近基因的策略，最近基因给出来了，但都是各种人类不友好的ID，我们不能把一切都交给计算机，输出的结果我们还是要看一看的，能不能把基因的ID换成对人类友好的基因名，并给出描述性的全称，这个必然可以有。&lt;/p&gt;

&lt;p&gt;只需要给&lt;strong&gt;annotatePeak&lt;/strong&gt;传入&lt;strong&gt;annoDb&lt;/strong&gt;参数就行了。&lt;/p&gt;

&lt;p&gt;如果你的&lt;strong&gt;TxDb&lt;/strong&gt;的基因ID是Entrez，它会转成ENSEMBL，反之亦然，当然不管是那一种，都会给出SYMBOL，还有描述性的GENENAME.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/2017-03-10-001907_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;citation:4b21ea5970cfe309bb59877ac4e1f485&#34;&gt;Citation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Yu G&lt;/em&gt;&lt;/strong&gt;, Wang LG and He QY&lt;sup&gt;*&lt;/sup&gt;. &lt;a href=&#34;http://bioinformatics.oxfordjournals.org/content/31/14/2382&#34;&gt;ChIPseeker: an R/Bioconductor package for ChIP peak annotation, comparison and visualization&lt;/a&gt;. &lt;strong&gt;&lt;em&gt;Bioinformatics&lt;/em&gt;&lt;/strong&gt; 2015, 31(14):2382-2383.&lt;/p&gt;

&lt;p&gt;&lt;script type=&#34;text/javascript&#34; src=&#34;https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js&#34;&gt;&lt;/script&gt;&lt;div class=&#34;altmetric-embed&#34; data-badge-type=&#34;donut&#34; data-badge-popover=&#34;right&#34; data-altmetric-id=&#34;3781087&#34;&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BED文件</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/bed%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 09 Mar 2017 00:13:57 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/bed%E6%96%87%E4%BB%B6/</guid>
      <description>

&lt;p&gt;BED的全称是Browser Extensible Data，顾名思义是为genome browser设计的，大名鼎鼎的bedtools可不是什么「床上用品」。&lt;/p&gt;

&lt;p&gt;BED包含有3个必须的字段和9个可选字段。&lt;/p&gt;

&lt;p&gt;三个字段包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 chrom - 染色体名字&lt;/li&gt;
&lt;li&gt;2 chromStart - 染色体起始位点&lt;/li&gt;
&lt;li&gt;3 chromEnd - 染色体终止位点&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;这里必须指出的是&lt;strong&gt;chromStart&lt;/strong&gt;是起始于0，而不是1。很多分析软件都忽略
了这一点，会有一个碱基的位移，据我所知Homer和ChIPseeker没有这个问题，而像peakAnalyzer, ChIPpeakAnno等都有位移的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可选的9个字段包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 name - 名字&lt;/li&gt;
&lt;li&gt;5 score - 分值(0-1000), 用于genome browser展示时上色。&lt;/li&gt;
&lt;li&gt;6 strand - 正负链，对于ChIPseq数据来说，&lt;strong&gt;一般&lt;/strong&gt;没有正负链信息。&lt;/li&gt;
&lt;li&gt;7 thickStart - 画矩形的起点&lt;/li&gt;
&lt;li&gt;8 thickEnd - 画矩形的终点&lt;/li&gt;
&lt;li&gt;9 itemRgb - RGB值&lt;/li&gt;
&lt;li&gt;10 blockCount - 子元件（比如外显子）的数目&lt;/li&gt;
&lt;li&gt;11 blockSizes - 子元件的大小&lt;/li&gt;
&lt;li&gt;12 blockStarts - 子元件的起始位点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般情况下，我们只用到前面5个字段，这也是做peak calling的MACS输出的字段。&lt;/p&gt;

&lt;p&gt;其中第5个字段，MACS的解释是这样子的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The 5th column in this file is the summit height of fragment pileup.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是片段堆积的峰高，这也不难理解，为什么我在ChIPseeker是画peak coverage的函数&lt;strong&gt;covplot&lt;/strong&gt;要有个*weightCol*的参数了。&lt;/p&gt;

&lt;h2 id=&#34;数据可视化:99328489e3689b55705b2759560872b2&#34;&gt;数据可视化&lt;/h2&gt;

&lt;p&gt;从名字上看，它是为genome browser而生，相应的，&lt;strong&gt;ChIPseeker&lt;/strong&gt;实现了*covplot*来可视化BED数据。&lt;/p&gt;

&lt;h3 id=&#34;covplot-支持直接读文件出图:99328489e3689b55705b2759560872b2&#34;&gt;&lt;strong&gt;covplot&lt;/strong&gt;支持直接读文件出图：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ChIPseeker)
library(ggplot2)

files &amp;lt;- getSampleFiles()

covplot(files[[4]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/covplot_1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;支持granges对象-同时可以多个文件或者grangeslist:99328489e3689b55705b2759560872b2&#34;&gt;支持GRanges对象，同时可以多个文件或者GRangesList&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;peak=GenomicRanges::GRangesList(CBX6=readPeakFile(files[[4]]),
                                CBX7=readPeakFile(files[[5]]))
covplot(peak, weightCol=&amp;quot;V5&amp;quot;) + facet_grid(chr ~ .id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/covplot_2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;支持可视化某个窗口:99328489e3689b55705b2759560872b2&#34;&gt;支持可视化某个窗口&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;covplot(peak, weightCol=&amp;quot;V5&amp;quot;, chrs=c(&amp;quot;chr17&amp;quot;, &amp;quot;chr18&amp;quot;), xlim=c(4e7, 5e7)) + facet_grid(chr ~ .id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/covplot_3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;拿到数据后，我们首先会可视化看一下数据，接下来就会想知道这些peak都和什么样的基因有关，这将在下次讲解，如何做注释。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;citation:99328489e3689b55705b2759560872b2&#34;&gt;Citation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Yu G&lt;/em&gt;&lt;/strong&gt;, Wang LG and He QY&lt;sup&gt;*&lt;/sup&gt;. &lt;a href=&#34;http://bioinformatics.oxfordjournals.org/content/31/14/2382&#34;&gt;ChIPseeker: an R/Bioconductor package for ChIP peak annotation, comparison and visualization&lt;/a&gt;. &lt;strong&gt;&lt;em&gt;Bioinformatics&lt;/em&gt;&lt;/strong&gt; 2015, 31(14):2382-2383.&lt;/p&gt;

&lt;p&gt;&lt;script type=&#34;text/javascript&#34; src=&#34;https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js&#34;&gt;&lt;/script&gt;&lt;div class=&#34;altmetric-embed&#34; data-badge-type=&#34;donut&#34; data-badge-popover=&#34;right&#34; data-altmetric-id=&#34;3781087&#34;&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux版迅雷</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/linux%E7%89%88%E8%BF%85%E9%9B%B7/</link>
      <pubDate>Mon, 06 Mar 2017 23:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/linux%E7%89%88%E8%BF%85%E9%9B%B7/</guid>
      <description>&lt;p&gt;上次讲了&lt;a href=&#34;http://guangchuangyu.github.io/2016/03/yet-an-unofficial-bioedit-for-osx/&#34;&gt;OSX版BioEdit&lt;/a&gt;，还蛮受欢迎，说到下载工具，linux的小伙伴们都想用迅雷，有没有？毕竟大家都想耍流氓。许久没打开迅雷，今日一打开，发现被学校给墙掉了。&lt;strong&gt;大写的杯具啊！&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You have attempted to use an application which is in violation of your internet usage policy.&lt;/p&gt;

&lt;p&gt;Thunder.Xunlei&lt;/p&gt;

&lt;p&gt;Category: P2P&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;老司机不能偷偷地下片 了，唯有分享出来，带大家上车。还好我有一张半年前的截屏，不然连张图都没有。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2016-08-29-121755_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这就是linux版的迅雷，系统状态栏最右下角有个小图标，也有个状态窗口，同时还支持浏览器整合，可以说该有的都有了。&lt;/p&gt;

&lt;p&gt;这实际上是迅雷的官方作品，是迅雷路由固件（Xware），要带到linux来做为桌面软件，需要一张皮，也就是今天要说的xware-desktop（社区开源作品），所以这是个半官方半社区的软件。&lt;/p&gt;

&lt;p&gt;安装还是挺简单的，到全球最大的同性交友网站github上搜索XwareDesktop，到了项目主页上，照着文档来就行。&lt;/p&gt;

&lt;p&gt;一打开xware-desktop的&lt;a href=&#34;https://github.com/Xinkai/XwareDesktop&#34;&gt;github repo&lt;/a&gt;，发现作者说他不维护了。不过不维护也没关系，因为这只是一张皮，等到什么时候不能用的，自会有人接手或者写新的，只要能在PC上跑的东西，没有搞不了的，只要迅雷有提供路由固件，老司机们就能开车。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>unknown annotation in enrichment analysis</title>
      <link>https://guangchuangyu.github.io/cn/2017/03/unknown-annotation-in-enrichment-analysis/</link>
      <pubDate>Fri, 03 Mar 2017 00:10:37 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/03/unknown-annotation-in-enrichment-analysis/</guid>
      <description>

&lt;p&gt;小伙伴说注释不全，比如KEGG只有不到1万个基因有注释，但他一次RNA-seq出来的基因有2万多个，那其它没注释那1万多个岂不是扔了？！就某个通路来说，两种情况，要么属于，要么不属于这个通路。那1万多个应该放在背景里，不要扔。&lt;/p&gt;

&lt;p&gt;我的解答是三种情况，1属于，2不属于，3不知道。对于缺失信息的，当然是扔。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/685336006.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然而他觉得影响不大，这必须是有影响的。我们算一下p值就知道了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;第一种情况-只搞大n:78c05f2a964a410613eebad16c9db2dc&#34;&gt;第一种情况，只搞大N&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; k
[1] 10
&amp;gt; n
[1] 100
&amp;gt; M
[1] 500
&amp;gt; N1
[1] 10000
&amp;gt; phyper(k-1, M, N1-M, n, lower.tail=F)
[1] 0.02751124
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如有这样的情况，算出来&lt;strong&gt;0.0275&lt;/strong&gt;，假如背景现在翻一翻，我们来看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; N2
[1] 20000
&amp;gt; phyper(k-1, M, N2-M, n, lower.tail=F)
[1] 0.0002018491
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p值变成正确的100分之一了。影响是如此之大！&lt;/p&gt;

&lt;h2 id=&#34;第二种情况-n和n都搞大:78c05f2a964a410613eebad16c9db2dc&#34;&gt;第二种情况，N和n都搞大&lt;/h2&gt;

&lt;p&gt;第一种情况是最常见的，有些web-server或软件，会有参数说估计一下物种的基因总数，这就是在搞大&lt;strong&gt;N&lt;/strong&gt;啊。&lt;/p&gt;

&lt;p&gt;然后你可能会觉得，N大了，那你的基因列表里没注释的也不能扔啊，N翻倍了，n也应该翻倍？！&lt;/p&gt;

&lt;p&gt;我们就当n也翻倍吧，看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; phyper(k-1, M, N2-M, n*2, lower.tail=F)
[1] 0.02930878
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好像是和正确答案差不多，然而大家有没有想到，这是有前提条件的，建立在完全随机的基因上，也就是说基因有没有注释的概率是一样的，我们在一个基因池子里随机捞一些出来研究，这显然是不成立的，有些通路就是被研究得很透，有些就是基本未知。科学上有些东西，就像个死火山，要靠某个突破之后突然喷发，研究上的东西，从来不是随机在发展。还拿KEGG来说吧，也就是代谢通路比较全。&lt;/p&gt;

&lt;p&gt;所以第一点，N翻倍了，n在事实上不会刚好也翻倍的。假如n是乘1.5吧，我们来看p值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; phyper(k-1, M, N2-M, n*1.5, lower.tail=F)
[1] 0.004529063
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是正确p值的1/7，差别还有蛮大的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;即使第二种情况成立，注释是随机的，你拿到的基因列表，也不应该是随机的，你无法对缺失注释的基因的分布做任何的估计，特别是对你的基因列表，不扔是错的。&lt;/p&gt;

&lt;p&gt;三种情况，属于、不属于和不知道，分别可以说是true, false, NA，不过滤的做法，其实是把NA全当成false了，这问题太明显了，不可能全是false，是不是false的比例对于不同的pathway来说也不一样！而具体情况当然NA的东西，它就是NA，鬼知道。&lt;/p&gt;

&lt;p&gt;所以必须要扔，注释信息本身是不全的，是有bias的，但这是现实，你没办法改善现实的情况下，起码不要想当然去把情况弄得更糟。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>根据GTF画基因的多个转录本结构</title>
      <link>https://guangchuangyu.github.io/cn/2017/02/%E6%A0%B9%E6%8D%AEgtf%E7%94%BB%E5%9F%BA%E5%9B%A0%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%BD%AC%E5%BD%95%E6%9C%AC%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 21 Feb 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/02/%E6%A0%B9%E6%8D%AEgtf%E7%94%BB%E5%9F%BA%E5%9B%A0%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%BD%AC%E5%BD%95%E6%9C%AC%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;这是&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;amp;mid=2247484044&amp;amp;idx=2&amp;amp;sn=56b45eaeb4ad344481afa05abeb1c53e&amp;amp;chksm=9b484237ac3fcb219e41d5653fb800f987e7d217bbb3a5a0c0170ffb8e402f4cc5f726212ef7&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0220calgiLgIZmjiiaNXZ0BE&amp;amp;key=df0a0b140e64a33b97880a54ee7cc95794b60a225d5338e88620674bed463405e61c5365394b7830750de8d3a88e122babd535c88c7d74b974b20c509218cf00d106c991a3a3f049c698a8f847aa5e06&amp;amp;ascene=0&amp;amp;uin=MTMxNjc4OTY2Mg%3D%3D&amp;amp;devicetype=iMac14%2C2+OSX+OSX+10.11.6+build&#34;&gt;生物技能树的一道习题&lt;/a&gt;，使用了base plot来画，做为补充，我使用ggplot2来重画一遍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;url &amp;lt;- &amp;quot;http://www.broadinstitute.org/cancer/cga/sites/default/files/data/tools/rnaseqc/gencode.v7.annotation_goodContig.gtf.gz&amp;quot;
tmpfile &amp;lt;- tempfile(fileext=&amp;quot;.gtf.gz&amp;quot;)
download.file(url, tmpfile)
gtf &amp;lt;- read.table(tmpfile,stringsAsFactors = F,
                  header = F,comment.char = &amp;quot;#&amp;quot;,sep = &#39;\t&#39;
                  )
gtf &amp;lt;- gtf[gtf[,2] ==&#39;HAVANA&#39;,]
gtf &amp;lt;- gtf[grepl(&#39;protein_coding&#39;,gtf[,9]),]
gtf$gene &amp;lt;- sapply(as.character(gtf[,9]), function(x) sub(&amp;quot;.*gene_name\\s([^;]+);.*&amp;quot;, &amp;quot;\\1&amp;quot;, x))

draw_gene &amp;lt;- &#39;ANXA1&#39;
structure &amp;lt;- gtf[gtf$gene==draw_gene,c(1,3:5)]
names(structure) &amp;lt;- c(&amp;quot;chr&amp;quot;, &amp;quot;record&amp;quot;, &amp;quot;start&amp;quot;, &amp;quot;end&amp;quot;)
idx &amp;lt;- which(structure$record == &amp;quot;transcript&amp;quot;)
s &amp;lt;- idx+1
e &amp;lt;- c(idx[-1]-1, nrow(structure))
g &amp;lt;- lapply(seq_along(s), function(i) {
  x &amp;lt;- structure[s[i]:e[i],]
  x$transcript &amp;lt;- i
  return(x)
}) %&amp;gt;% do.call(rbind, .)

g &amp;lt;- g[g$record == &amp;quot;exon&amp;quot;,]
g$transcript &amp;lt;- factor(g$transcript)

library(ggplot2)
ggplot(g) + 
	geom_segment(aes(x=start, xend=end, y=transcript, yend=transcript, color=transcript), size=2) + 
	theme(legend.position=&amp;quot;none&amp;quot;) + labs(title=&amp;quot;ANXA1&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/gtf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ChIPseq简介</title>
      <link>https://guangchuangyu.github.io/cn/2017/02/chipseq%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 20 Feb 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/02/chipseq%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;p&gt;ChIP是指染色质免疫沉淀，它通过特异结合抗体将DNA结合蛋白免疫沉淀，可以用于捕获蛋白质（如转录因子，组蛋白修饰）的DNA靶点。这技术存在非常久了，在二代测序之前，结合microarray，它的名字叫&lt;code&gt;ChIP-on-chip&lt;/code&gt;，二代测序出来之后，显而易见的，免疫沉淀拉下来的DNA拿去NGS测序，这必然是下一代的ChIP技术，优点也是显而易见的，不再需要设计探针（往往存在着一定的偏向性）。所以NGS出来以后，不差钱的牛逼实验室显然占据上风，谁先做出来，谁就定义了新技术。这是有钱人的竞赛，没钱的只能等着技术烂大街的时候跟风做。&lt;/p&gt;

&lt;p&gt;这是显而易见的下一代技术，外加技术上完全是可行的，所以这是一场单纯的时间竞赛，于是几乎同时出来CNS文章，基本上谁也不比谁差地同时扔出来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Johnson DS, Mortazavi A et al. (2007) Genome-wide mapping of in vivo protein–DNA interactions. Science 316: 1497–1502&lt;/li&gt;
&lt;li&gt;Robertson G et al.(2007) Genome-wide profiles of STAT1 DNA association using chromatin immunoprecipitation and massively parallel sequencing. Nature Methods 4: 651–657&lt;/li&gt;
&lt;li&gt;Schmid et al. (2007) ChIP-Seq Data reveal nucleosome architecture of human promoters. Cell 131: 831–832&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2007年来自三个不同的实验室，几乎是同时间出来（最长差不了3个月），分别发CNS，一起定义了这个&lt;code&gt;ChIPseq&lt;/code&gt;技术。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/chipseq.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个技术分为4步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cross-linking&lt;/li&gt;
&lt;li&gt;Sonication&lt;/li&gt;
&lt;li&gt;IP&lt;/li&gt;
&lt;li&gt;Sequencing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNA和蛋白质交联(cross-linking)，超声(sonication)将染色体随机切割，利用抗原抗体的特异性识别(IP)，把&lt;strong&gt;目标蛋白&lt;/strong&gt;相结合的DNA片段沉淀下来，反交联释放DNA片段，最后是测序(sequencing)。&lt;/p&gt;

&lt;p&gt;一个典型的分析流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/Bioconductor/ChIPseeker/CS/ChIP-seq-1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;测序之后，我们当然首先需要做质量控制，然后就是做mapping，拿到这些DNA片段在染色体上的位置信息，ChIPseq的数据我们还需要做peak calling，把背景噪声去掉，比如上图中使用MACS做peak calling，这样我们就得到了protein binding site (peak)，就可以做下游的分析，比如可视化、相关的基因（比如最近的基因、宿主基因）、Motif分析等等。&lt;/p&gt;

&lt;p&gt;Peak annotation做的就是binding site的相关基因注释，在讲解&lt;code&gt;ChIPseeker&lt;/code&gt;的注释功能之前，下次先讲解一下peak calling的输出，BED文件。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;citation:f7b0a5b14beddee41d112cfd5bca1431&#34;&gt;Citation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Yu G&lt;/em&gt;&lt;/strong&gt;, Wang LG and He QY&lt;sup&gt;*&lt;/sup&gt;. &lt;a href=&#34;http://bioinformatics.oxfordjournals.org/content/31/14/2382&#34;&gt;ChIPseeker: an R/Bioconductor package for ChIP peak annotation, comparison and visualization&lt;/a&gt;. &lt;strong&gt;&lt;em&gt;Bioinformatics&lt;/em&gt;&lt;/strong&gt; 2015, 31(14):2382-2383.&lt;/p&gt;

&lt;p&gt;&lt;script type=&#34;text/javascript&#34; src=&#34;https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js&#34;&gt;&lt;/script&gt;&lt;div class=&#34;altmetric-embed&#34; data-badge-type=&#34;donut&#34; data-badge-popover=&#34;right&#34; data-altmetric-id=&#34;3781087&#34;&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wrapping labels in ggplot2</title>
      <link>https://guangchuangyu.github.io/cn/2017/02/wrapping-labels-in-ggplot2/</link>
      <pubDate>Tue, 14 Feb 2017 09:50:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/02/wrapping-labels-in-ggplot2/</guid>
      <description>&lt;p&gt;在公众号biobabble后台有多人同时在问这个问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-02-12-223832_646x667_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;晒这个截屏主要想说一点，如果是一两句话就能说清楚的问题，可以提问，如果不是，则不要在后台提问，写邮件或者到论坛提问，是更好的方式，像截屏中显示的，图片显示过期，我根本就没看到过图片。在手机上是无法看的，而我正好几天没在电脑前，于是你们发的图片我看不了，而且我如果没有在24小时之内回复，公众平台就不允许我回复了，因为问题已经过期。所以在此强调，不要在后台发图片提问，不要在后台问稍复杂的问题。&lt;/p&gt;

&lt;p&gt;这个问题其实很简单，用&lt;code&gt;stringr&lt;/code&gt;包的&lt;code&gt;str_wrap&lt;/code&gt;来完成文本自动换行就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(stringr)
library(ggplot2)
library(clusterProfiler)
data(geneList)
de &amp;lt;- names(geneList)[1:100]
x &amp;lt;- enrichKEGG(de)
p &amp;lt;- barplot(x) 
p + scale_x_discrete(labels=function(x) str_wrap(x, width=10))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-02-12-225944_635x776_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ggtree发表</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/ggtree%E5%8F%91%E8%A1%A8/</link>
      <pubDate>Sun, 22 Jan 2017 15:10:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/ggtree%E5%8F%91%E8%A1%A8/</guid>
      <description>&lt;p&gt;MEE在18号出版了今年（第8卷）第1期，ggtree正好在这一期出版，一经出版就有几条推在传播, 我也是在推特上看到，才发现，哦原来我的文章出版了。然后我又发现2017年新鲜出炉有了一篇PNAS的引用。&lt;/p&gt;

&lt;p&gt;我以前没接触过进化，来了现在这个实验室，发现可视化是个大问题，大家都在用AI，慢慢地抠，对于一些和进化树相关的数据，自己一点一点地在AI里面加上去。甚至于genotype table是一个框一个框地在AI里面加的。一方面画一顆树可能用掉你几天的时间，另一方面，太容易出错了，再者你花的时间并不能转化为生产力，每一次你都要这么搞！这简直就是水深火热啊！&lt;/p&gt;

&lt;p&gt;我也帮师兄写过一些代码，给定进化树上节点的序列，我比较父节点和子节点，把碱基或氨基酸替换写到newick树的node label，然后就可以用软件展示序列的替换情况。教会了师兄，他再去给他的师弟师妹们演示，说以后咱们可以这么干了，一个个觉得很牛逼，我内心想的是，愚蠢的人类啊，node label只能存一个信息，牛逼的方式应该是可以展示多个维度的信息，通过图层自由组合。这个时候我就产生了要写ggtree的想法。&lt;/p&gt;

&lt;p&gt;我其实也挺惊讶的，进化这个领域，竟然有这么大的坑，等我这个新手来填。在2014年底开始写，在我写了基本几个图层，可以画树做一些注释的时候，我首要解决的就是你来个数据，我可以加到树上去做注释，所以在最初的版本，就有%&amp;lt;+%这个操作符，使用的是p %&amp;lt;+% d + geom这样的语法，你画了颗树p，有个数据d，可以通过%&amp;lt;+%操作符把数据关联起来，然后这个数据就可以在后续的图层geom里用了。我对这个操作符还是很满意的，主要是傻瓜化，然后它可以解决一大票关联数据做注释的事情。后面一个相关的是facet_plot函数，这个关联的是图，使用的语法是facet_plot(p, panel, data, geom, mapping), 你有数据data，要用geom(mapping, data)来画一个图，我可以把这个图和树p关联起来，画在panel上，而geom(mapping, data)画出来的图，会自动按照树的拓扑结构重新排列。&lt;/p&gt;

&lt;p&gt;在之前我跟实验室的小伙伴推荐ggplot2，大家觉得很牛逼，但没人想学。学生物出身的人，天生对命令行是抗拒的，但有了ggtree，很多人都愿意学了，因为用AI搞进化树真心水深火热！学ggtree也需要时间，但花的时间可以转化为生产力啊，越搞越顺手，越来越有能力做出逼格高的图，而且花费的时间越来越少。虽然和我同级的同学都是纯生物出身，但现在已经一个个可以做出很有逼格的图了，当然和作者在同一屋檐下也是很有关系的😜。&lt;/p&gt;

&lt;p&gt;ggtree有很多好玩的东西，可以做出非常复杂的图，前阵子推送了我在人大做报告的幻灯片，后台有人问我第一张图中那些小动物的图是那里找来的？显然如果有看我之前的emojifont包，就会知道，这是ggtree+emojifont画出来的。那个幻灯片里面所有的进化树，都是ggtree画的。ggtree有很多的功能，其实大家还不清楚，尽管我写了很详细的文档，写了很多篇博客来介绍，但还是有些细节没讲到，也有些东西可能大家想不到应用场景，或者你有东西想要做，却不知道怎么来实现。我的邮箱里ggtree这个标签下面已经有344封邮件（其实起码要翻倍，因为同一主题的来来往往好多邮只会被当成1封，几乎每天都会有邮件），很多的问题其实反复被问到，所以我后来不直接在邮件里回复，而是要求大家去google group里问。google group其实是邮件列表，有个好处，就如同如何获取文献中说的RSS推送一般，如果用户订阅了，但凡有人提问，有人回答，你都可以收到邮件，这样子，用户可以参与帮忙解决问题，一个问题的解决，大家都可以看到，或者也有收益。别的用户有同样的问题，在网上还能搜到答案，多方收益，我也可以减少回答问题。有兴趣的同学，可以往&lt;a href=&#34;mailto:bioc-ggtree+subscribe@googlegroups.com&#34;&gt;bioc-ggtree+subscribe@googlegroups.com&lt;/a&gt;发邮件订阅。&lt;/p&gt;

&lt;p&gt;正好准备过年停止更新，等年后再来，又正好ggtree刚好出版，算是庆祝一下吧。不管你有任何关于ggtree的问题，你都可以在留言区里问我，大家可以分享这篇文章，让更多的人参与，因为别人可能会问出你想不到的问题，而我解答别人的问题，你或许也能学习受益。如果有人提的问题正好也是你关心的，请给他/她点赞，点赞多的问题，我会优先回答。这个过程持续到年后，我会在年后找个时间集中回答。&lt;/p&gt;

&lt;p&gt;虽然现在引文不多，但我已经开始在收集&lt;a href=&#34;https://guangchuangyu.github.io/ggtree/gallery/&#34;&gt;论文里用ggtree画的图&lt;/a&gt;了，以后肯定会有越来越多有逼格的图出来，也算是一个侧面给大家展示ggtree可以做什么。&lt;/p&gt;

&lt;p&gt;请记住一点，投入时间学习是有回报的，因为你的投入可以转化为生产力，而不像AI你搞再多，也只是机械式重复，并不能因为你用AI注释树而让你有能力去做美工-,-，但学ggtree，你会的不止是进化树的可视化，你同时必须还会用ggplot2来展示你其它的各种数据。套用如何获取文献中的梗，如果你还在用AI手工注释你的进化树，你该吞下红色药丸了。ggtree是你的朋友！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微信公众文markdown一键排版</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E6%96%87markdown%E4%B8%80%E9%94%AE%E6%8E%92%E7%89%88/</link>
      <pubDate>Wed, 18 Jan 2017 00:53:00 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E6%96%87markdown%E4%B8%80%E9%94%AE%E6%8E%92%E7%89%88/</guid>
      <description>&lt;p&gt;微信公众号的后台排版功能很差，要想让读者阅读起来舒服，写作的人要花很多时间，于是出现了像&lt;code&gt;秀米&lt;/code&gt;这样的第三方排版网站，即便如此，要想排出好的版面，仍然是件耗时的事情，而且像在文章里贴代码这种小众需求，是不被支持的，代码就像普通文本，那叫一个乱。&lt;/p&gt;

&lt;p&gt;好在微信平台是支持富文本的，我们复制粘贴过来，格式都还会在，像抄我ggplot2那篇文的&lt;code&gt;生信人&lt;/code&gt;，就是完全复制粘贴的，还是我博客上的排版，当然它到了公众号上就乱了，我们其实很容易发现很多复制粘贴的，都没自己排一下版面，直接&lt;code&gt;ctrl-C&lt;/code&gt;, &lt;code&gt;ctrl-V&lt;/code&gt;一点诚意都没有。&lt;/p&gt;

&lt;p&gt;支持富文本这一点，意味着我们可以用&lt;code&gt;markdown&lt;/code&gt;呀！排版很容易，并且可以支持语法高亮。上一篇文章&lt;a href=&#34;https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/&#34;&gt;CorMut&lt;/a&gt;里，就是用了&lt;code&gt;markdown&lt;/code&gt;，被眼尖的小朋友发现，所以写出来，解答一下。&lt;/p&gt;

&lt;p&gt;我们需要的是，安装一个&lt;code&gt;markdown here&lt;/code&gt;的插件，firefox，chrome等都是支持的。&lt;/p&gt;

&lt;p&gt;比如下面这个：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003058_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我点一下markdown渲染，它自己就变成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003121_1280x800_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这玩意其实是设计来写邮件的，有了它，邮件排版可以很牛逼，比如还是刚才的代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-18-003253_516x590_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们还可以通过定制&lt;code&gt;css&lt;/code&gt;，来改变字体、颜色等。简单的markdown语法，让排版轻松愉快，而且本身我的博客就是用markdown写的，写一份文档，博客和公众号两边推送。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> R包辣鸡之CorMut</title>
      <link>https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/</link>
      <pubDate>Tue, 17 Jan 2017 12:23:16 +0800</pubDate>
      
      <guid>https://guangchuangyu.github.io/cn/2017/01/r%E5%8C%85%E8%BE%A3%E9%B8%A1%E4%B9%8Bcormut/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;曾经QQ上有人叫我帮忙，跑某个R包做个分析，我一看那包，一堆bug，显然不能用，那就不是简单的事了，我可没空帮他写代码，于是他就经常恶心我，有事没事就来说我写ggtree没意义，不是实质科研，不如跟他做点牛逼的，不如再写个R包干他那事。昨天用马甲在进化群里问画树，我还热心贴个代码给他，说看不懂，我在群里说了，我写个文详细介绍一下。然而他的马甲身份暴露啦，所以今日跳票，我写好的文也不发了，你牛逼就不要用马甲来骗代码呀，ggtree没用你不要用呀，叔就是这么任性😎&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前讲过某个R包我一看一堆bug，直接放弃，今天倒是拿出来晒一下，不为别的，我只想说一句，一知半解是很危险的，盲目相信软件也是很危险的。&lt;/p&gt;

&lt;h2 id=&#34;比对-不比对-这是个严肃的问题:73d341715265d4d00941b1a9c2cbba18&#34;&gt;比对？不比对？这是个严肃的问题&lt;/h2&gt;

&lt;p&gt;话说此包的输入是alignment，我刚开始也没看代码，照着示例跑一下，但读序列的时候，我就惊呆了，怎么读个fasta这么慢，于是我开始看代码，不看不知道，一看吓一跳：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;seq_f01=as.list(sapply(allSeq,function(x)c2s(s2c(x)[ref01!=&amp;quot;-&amp;quot;])))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个s2c把string变成character vector，c2s则反过来，这一句就干一件简单的事情，就是把所有string（fasta读进来的sequences）中的-全部删除。就这么一切一贴，非常非常慢，简单地用&lt;code&gt;gsub(“-“, “”, allSeq)&lt;/code&gt;就可以非常快速做同样的事情。
然后这时候我们似乎觉得那里不妥！你把&lt;code&gt;-&lt;/code&gt;全删了，等于是把比对序列变成了非比对序列。那么你要求输入是比对序列是为什么？！
确实序列必须得是比对好的，因为这包就是要检测correlated mutations，它比的是codon, 这必须是比对好的序列才行，但在读序列的时候，就把-给删了，序列不再是比对好的，本来对应的codon现在必然很多都移位了，这在一开始就挖了巨大的坑。后面所有的计算必须都是辣鸡了。&lt;/p&gt;

&lt;h2 id=&#34;codon比较-数数字你会吗:73d341715265d4d00941b1a9c2cbba18&#34;&gt;codon比较，数数字你会吗？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Bioconductor-mirror/CorMut/blob/master/R/CorMut-internal.R#L125-L129&#34;&gt;https://github.com/Bioconductor-mirror/CorMut/blob/master/R/CorMut-internal.R#L125-L129&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;for(j in 1:length(seqf[[i]])){
	if(j%%3==1){ tris=seqf[[i]][j:(j+2)]
	}else if(j%%3==2){ tris=seqf[[i]][(j-1):(j+1)]
	}else if(j%%3==0){ tris=seqf[[i]][(j-2):j]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这循环竟然不是一个codon一个codon来，而是一个base一个base地迭代，这里移动三个位置，拿到的都是同一个codon，然后它就去比较是否不同，数数目了，一个不同，数它3遍，我也是醉了。&lt;/p&gt;

&lt;h2 id=&#34;p值你会算吗:73d341715265d4d00941b1a9c2cbba18&#34;&gt;p值你会算吗？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Bioconductor-mirror/CorMut/blob/release-3.4/R/kaksAA.R#L67-L77&#34;&gt;https://github.com/Bioconductor-mirror/CorMut/blob/release-3.4/R/kaksAA.R#L67-L77&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;LOD=0
Nnum=NS+NY
for(ii in NYs:Nnum){
	per_item=choose(Nnum,ii)*(q^ii)*((1-q)^(Nnum-ii))
	#avoid the appear of NaN
	if(per_item!=&amp;quot;NaN&amp;quot;){
		LOD=per_item+LOD
	}
	#print(choose(dim(mat)[2],i)*(q^i)*((1-q)^(dim(mat)[2]-i)))
}
LOD=-log10(LOD)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道算p值是算积分面积，它倒好，离散性分布这一个个数字来计算，然后求合。
这里用的是二项式分布：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;per_item=choose(Nnum,ii)(q^ii)((1-q)^(Nnum-ii))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个基本上你算出来会有很多0和NaN，精度问题嘛，这样算必须是不准的。然后他必须是跑了自己代码出不来p值，发现有很多NaN，也不去想为什么，直接把NaN给扔了。这根本就是错的，也不知道用pbinom去算，我也是服了。&lt;/p&gt;

&lt;h2 id=&#34;总结:73d341715265d4d00941b1a9c2cbba18&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我只是粗略地看了一下代码，就发现很多错误，而且几乎每个重要的部分都出错。问题肯定比我粗略看一下所能发现地多得多。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读序列，把比对的序列搞成了非比对。&lt;/li&gt;
&lt;li&gt;比较codon，序列非比对这比毛线啊，然后连数数目都数错。&lt;/li&gt;
&lt;li&gt;p值，简单二项式，你都不会算啊，简单粗暴地对NaN视而不见。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这货中国CDC出品，竟然还发了Bioinformatics，reviewer简直瞎眼了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://guangchuangyu.github.io/blog_images/2017/2017-01-09-002515_560x405_scrot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>